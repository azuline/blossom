# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any, AsyncIterator
import sqlalchemy
import psycopg
from database.conn import DBConn
from database.__codegen_db__ import models
from foundation.observability.errors import NotFoundError

AUTHN_USER_FETCH_BY_EMAIL = r"""-- name: authn_user_fetch_by_email \:one
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE email = :p1
"""

async def query_authn_user_fetch_by_email(conn: DBConn, *, email: str) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_USER_FETCH_BY_EMAIL), {"p1": email})).first()
    if row is None:
        raise NotFoundError(resource="authn_user_fetch_by_email", key_name="email", key_value=str(email))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

AUTHN_SESSION_CREATE = r"""-- name: authn_session_create \:one
INSERT INTO sessions (user_id, organization_id)
VALUES (:p1, :p2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""

async def query_authn_session_create(conn: DBConn, *, user_id: str, organization_id: str | None) -> models.SessionModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_SESSION_CREATE), {"p1": user_id, "p2": organization_id})).first()
    if row is None:
        raise NotFoundError(resource="authn_session_create", key_name="user_id", key_value=str(user_id))
    return models.SessionModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

AUTHN_SESSION_EXPIRE = r"""-- name: authn_session_expire \:exec
UPDATE sessions
SET expired_at = NOW() 
WHERE id = :p1
"""

async def query_authn_session_expire(conn: DBConn, *, id: str) -> None:
    await conn.execute(sqlalchemy.text(AUTHN_SESSION_EXPIRE), {"p1": id})

AUTHN_LINKED_ORGANIZATION_FETCH = r"""-- name: authn_linked_organization_fetch \:one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
WHERE tu.user_id = :p1 AND t.id = :p2
"""

async def query_authn_linked_organization_fetch(conn: DBConn, *, user_id: str, id: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_LINKED_ORGANIZATION_FETCH), {"p1": user_id, "p2": id})).first()
    if row is None:
        raise NotFoundError(resource="authn_linked_organization_fetch", key_name="user_id", key_value=str(user_id))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

AUTHN_MOST_RECENTLY_ACCESSED_ORGANIZATION_FETCH = r"""-- name: authn_most_recently_accessed_organization_fetch \:one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
LEFT JOIN sessions s ON s.organization_id = t.id AND s.user_id = tu.user_id
WHERE tu.user_id = :p1
ORDER BY s.last_seen_at DESC NULLS LAST, t.id ASC
LIMIT 1
"""

async def query_authn_most_recently_accessed_organization_fetch(conn: DBConn, *, user_id: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_MOST_RECENTLY_ACCESSED_ORGANIZATION_FETCH), {"p1": user_id})).first()
    if row is None:
        raise NotFoundError(resource="authn_most_recently_accessed_organization_fetch", key_name="user_id", key_value=str(user_id))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

AUTHN_SESSION_FETCH_BY_USER = r"""-- name: authn_session_fetch_by_user \:one
SELECT id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
FROM sessions
WHERE user_id = :p1
ORDER BY last_seen_at DESC
LIMIT 1
"""

async def query_authn_session_fetch_by_user(conn: DBConn, *, user_id: str) -> models.SessionModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_SESSION_FETCH_BY_USER), {"p1": user_id})).first()
    if row is None:
        raise NotFoundError(resource="authn_session_fetch_by_user", key_name="user_id", key_value=str(user_id))
    return models.SessionModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

