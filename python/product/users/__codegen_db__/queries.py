# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any, AsyncIterator
import sqlalchemy
import psycopg
from database.conn import DBConn
from database.__codegen_db__ import models
from foundation.observability.errors import NotFoundError

USER_FETCH = """\
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE id = :p1
"""

async def query_user_fetch(conn: DBConn, *, id: str) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(USER_FETCH), {"p1": id})).first()
    if row is None:
        raise NotFoundError(resource="user_fetch", key_name="id", key_value=str(id))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

USER_CREATE = """\
INSERT INTO users (name, email, password_hash, signup_step)
VALUES (:p1, :p2, :p3, :p4)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""

async def query_user_create(conn: DBConn, *, name: str, email: str, password_hash: str | None, signup_step: str) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(USER_CREATE), {"p1": name, "p2": email, "p3": password_hash, "p4": signup_step})).first()
    if row is None:
        raise NotFoundError(resource="user_create", key_name="name", key_value=str(name))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

