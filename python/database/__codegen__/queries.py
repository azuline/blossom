# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models
from foundation.observability.errors import NotFoundError

VAULT_SECRET_CREATE = """-- name: vault_secret_create :one
INSERT INTO vaulted_secrets (organization_id, ciphertext)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, organization_id, ciphertext
"""

async def vault_secret_create(conn: DBConn, *, organization_id: str, ciphertext: str) -> models.VaultedSecretModel:
    row = (await conn.execute(sqlalchemy.text(VAULT_SECRET_CREATE), {"p1": organization_id, "p2": ciphertext})).first()
    if row is None:
        raise NotFoundError(resource="vaultedsecret", key_name="organization_id", key_value=str(organization_id))
    return models.VaultedSecretModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        organization_id=row[4],
        ciphertext=row[5],
    )

VAULT_SECRET_FETCH = """-- name: vault_secret_fetch :one
SELECT id, created_at, updated_at, storytime, organization_id, ciphertext
FROM vaulted_secrets
WHERE id = $1
"""

async def vault_secret_fetch(conn: DBConn, *, id: str) -> models.VaultedSecretModel:
    row = (await conn.execute(sqlalchemy.text(VAULT_SECRET_FETCH), {"p1": id})).first()
    if row is None:
        raise NotFoundError(resource="vaultedsecret", key_name="id", key_value=str(id))
    return models.VaultedSecretModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        organization_id=row[4],
        ciphertext=row[5],
    )

VAULT_SECRET_DELETE = """-- name: vault_secret_delete :exec
DELETE
FROM vaulted_secrets
WHERE id = $1
"""

async def vault_secret_delete(conn: DBConn, *, id: str) -> None:
    await conn.execute(sqlalchemy.text(VAULT_SECRET_DELETE), {"p1": id})

TEST_USER_CREATE = """-- name: test_user_create :one
INSERT INTO users (name, email, password_hash, signup_step, is_enabled)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""

async def test_user_create(conn: DBConn, *, name: str, email: str, password_hash: str | None, signup_step: str, is_enabled: bool) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(TEST_USER_CREATE), {"p1": name, "p2": email, "p3": password_hash, "p4": signup_step, "p5": is_enabled})).first()
    if row is None:
        raise NotFoundError(resource="user", key_name="name", key_value=str(name))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

TEST_ORGANIZATION_CREATE = """-- name: test_organization_create :one
INSERT INTO organizations (name, inbound_source)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, name, inbound_source
"""

async def test_organization_create(conn: DBConn, *, name: str, inbound_source: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(TEST_ORGANIZATION_CREATE), {"p1": name, "p2": inbound_source})).first()
    if row is None:
        raise NotFoundError(resource="organization", key_name="name", key_value=str(name))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

TEST_ORGANIZATION_USER_CREATE = """-- name: test_organization_user_create :one
INSERT INTO organizations_users (user_id, organization_id)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, removed_at, removed_by_user
"""

async def test_organization_user_create(conn: DBConn, *, user_id: str, organization_id: str) -> models.OrganizationsUserModel:
    row = (await conn.execute(sqlalchemy.text(TEST_ORGANIZATION_USER_CREATE), {"p1": user_id, "p2": organization_id})).first()
    if row is None:
        raise NotFoundError(resource="organizationsuser", key_name="user_id", key_value=str(user_id))
    return models.OrganizationsUserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        removed_at=row[6],
        removed_by_user=row[7],
    )

TEST_SESSION_CREATE = """-- name: test_session_create :one
INSERT INTO sessions (user_id, organization_id, expired_at, last_seen_at)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""

async def test_session_create(conn: DBConn, *, user_id: str, organization_id: str | None, expired_at: Any | None, last_seen_at: Any) -> models.SessionModel:
    row = (await conn.execute(sqlalchemy.text(TEST_SESSION_CREATE), {"p1": user_id, "p2": organization_id, "p3": expired_at, "p4": last_seen_at})).first()
    if row is None:
        raise NotFoundError(resource="session", key_name="user_id", key_value=str(user_id))
    return models.SessionModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

AUTHN_USER_FETCH_BY_EMAIL = """-- name: authn_user_fetch_by_email :one
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE email = $1
"""

async def authn_user_fetch_by_email(conn: DBConn, *, email: str) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_USER_FETCH_BY_EMAIL), {"p1": email})).first()
    if row is None:
        raise NotFoundError(resource="user", key_name="email", key_value=str(email))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

AUTHN_SESSION_CREATE = """-- name: authn_session_create :one
INSERT INTO sessions (user_id, organization_id)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""

async def authn_session_create(conn: DBConn, *, user_id: str, organization_id: str | None) -> models.SessionModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_SESSION_CREATE), {"p1": user_id, "p2": organization_id})).first()
    if row is None:
        raise NotFoundError(resource="session", key_name="user_id", key_value=str(user_id))
    return models.SessionModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

AUTHN_SESSION_EXPIRE = """-- name: authn_session_expire :exec
UPDATE sessions
SET expired_at = NOW() 
WHERE id = $1
"""

async def authn_session_expire(conn: DBConn, *, id: str) -> None:
    await conn.execute(sqlalchemy.text(AUTHN_SESSION_EXPIRE), {"p1": id})

AUTHN_LINKED_ORGANIZATION_FETCH = """-- name: authn_linked_organization_fetch :one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
WHERE tu.user_id = $1 AND t.id = $2
"""

async def authn_linked_organization_fetch(conn: DBConn, *, user_id: str, id: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_LINKED_ORGANIZATION_FETCH), {"p1": user_id, "p2": id})).first()
    if row is None:
        raise NotFoundError(resource="organization", key_name="user_id", key_value=str(user_id))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

AUTHN_MOST_RECENTLY_ACCESSED_ORGANIZATION_FETCH = """-- name: authn_most_recently_accessed_organization_fetch :one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
LEFT JOIN sessions s ON s.organization_id = t.id AND s.user_id = tu.user_id
WHERE tu.user_id = $1
ORDER BY s.last_seen_at DESC NULLS LAST, t.id ASC
LIMIT 1
"""

async def authn_most_recently_accessed_organization_fetch(conn: DBConn, *, user_id: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_MOST_RECENTLY_ACCESSED_ORGANIZATION_FETCH), {"p1": user_id})).first()
    if row is None:
        raise NotFoundError(resource="organization", key_name="user_id", key_value=str(user_id))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

AUTHN_SESSION_FETCH_BY_USER = """-- name: authn_session_fetch_by_user :one
SELECT id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
FROM sessions
WHERE user_id = $1
ORDER BY last_seen_at DESC
LIMIT 1
"""

async def authn_session_fetch_by_user(conn: DBConn, *, user_id: str) -> models.SessionModel:
    row = (await conn.execute(sqlalchemy.text(AUTHN_SESSION_FETCH_BY_USER), {"p1": user_id})).first()
    if row is None:
        raise NotFoundError(resource="session", key_name="user_id", key_value=str(user_id))
    return models.SessionModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

RPC_UNEXPIRED_SESSION_FETCH = """-- name: rpc_unexpired_session_fetch :one
SELECT id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
FROM sessions
WHERE id = $1
AND expired_at IS NULL
AND last_seen_at > NOW() - '14 days'::INTERVAL
"""

async def rpc_unexpired_session_fetch(conn: DBConn, *, id: str) -> models.SessionModel:
    row = (await conn.execute(sqlalchemy.text(RPC_UNEXPIRED_SESSION_FETCH), {"p1": id})).first()
    if row is None:
        raise NotFoundError(resource="session", key_name="id", key_value=str(id))
    return models.SessionModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

ORGANIZATION_FETCH = """-- name: organization_fetch :one
SELECT id, created_at, updated_at, storytime, name, inbound_source
FROM organizations
WHERE id = $1
"""

async def organization_fetch(conn: DBConn, *, id: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(ORGANIZATION_FETCH), {"p1": id})).first()
    if row is None:
        raise NotFoundError(resource="organization", key_name="id", key_value=str(id))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

ORGANIZATION_CREATE = """-- name: organization_create :one
INSERT INTO organizations (name, inbound_source)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, name, inbound_source
"""

async def organization_create(conn: DBConn, *, name: str, inbound_source: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(ORGANIZATION_CREATE), {"p1": name, "p2": inbound_source})).first()
    if row is None:
        raise NotFoundError(resource="organization", key_name="name", key_value=str(name))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

ORGANIZATION_USER_ADD = """-- name: organization_user_add :one
INSERT INTO organizations_users (organization_id, user_id)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, removed_at, removed_by_user
"""

async def organization_user_add(conn: DBConn, *, organization_id: str, user_id: str) -> models.OrganizationsUserModel:
    row = (await conn.execute(sqlalchemy.text(ORGANIZATION_USER_ADD), {"p1": organization_id, "p2": user_id})).first()
    if row is None:
        raise NotFoundError(resource="organizationsuser", key_name="organization_id", key_value=str(organization_id))
    return models.OrganizationsUserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        removed_at=row[6],
        removed_by_user=row[7],
    )

ORGANIZATION_FETCH_ALL = """-- name: organization_fetch_all :many
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
WHERE tu.user_id = $1
"""

async def organization_fetch_all(conn: DBConn, *, user_id: str) -> AsyncIterator[models.OrganizationModel]:
    result = await conn.execute(sqlalchemy.text(ORGANIZATION_FETCH_ALL), {"p1": user_id})
    async for row in result:
        yield models.OrganizationModel(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            inbound_source=row[5],
        )

USER_FETCH = """-- name: user_fetch :one
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE id = $1
"""

async def user_fetch(conn: DBConn, *, id: str) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(USER_FETCH), {"p1": id})).first()
    if row is None:
        raise NotFoundError(resource="user", key_name="id", key_value=str(id))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

USER_CREATE = """-- name: user_create :one
INSERT INTO users (name, email, password_hash, signup_step)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""

async def user_create(conn: DBConn, *, name: str, email: str, password_hash: str | None, signup_step: str) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(USER_CREATE), {"p1": name, "p2": email, "p3": password_hash, "p4": signup_step})).first()
    if row is None:
        raise NotFoundError(resource="user", key_name="name", key_value=str(name))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

