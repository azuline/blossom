# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: queries.sql
import datetime
from typing import Any, AsyncIterator, Optional

import psycopg

from database.__codegen__ import models


AUTHN_LINKED_ORGANIZATION_FETCH = """-- name: authn_linked_organization_fetch \\:one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
WHERE tu.user_id = %(p1)s AND t.id = %(p2)s
"""


AUTHN_MOST_RECENTLY_ACCESSED_ORGANIZATION_FETCH = """-- name: authn_most_recently_accessed_organization_fetch \\:one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
LEFT JOIN sessions s ON s.organization_id = t.id AND s.user_id = tu.user_id
WHERE tu.user_id = %(p1)s
ORDER BY s.last_seen_at DESC NULLS LAST, t.id ASC
LIMIT 1
"""


AUTHN_SESSION_CREATE = """-- name: authn_session_create \\:one
INSERT INTO sessions (user_id, organization_id)
VALUES (%(p1)s, %(p2)s)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""


AUTHN_SESSION_EXPIRE = """-- name: authn_session_expire \\:exec
UPDATE sessions
SET expired_at = NOW() 
WHERE id = %(p1)s
"""


AUTHN_SESSION_FETCH_BY_USER = """-- name: authn_session_fetch_by_user \\:one
SELECT id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
FROM sessions
WHERE user_id = %(p1)s
ORDER BY last_seen_at DESC
LIMIT 1
"""


AUTHN_USER_FETCH_BY_EMAIL = """-- name: authn_user_fetch_by_email \\:one
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE email = %(p1)s
"""


ORGANIZATION_ADD_USER = """-- name: organization_add_user \\:one
INSERT INTO organizations_users (organization_id, user_id)
VALUES (%(p1)s, %(p2)s)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, removed_at, removed_by_user
"""


ORGANIZATION_CREATE = """-- name: organization_create \\:one
INSERT INTO organizations (name, inbound_source)
VALUES (%(p1)s, %(p2)s)
RETURNING id, created_at, updated_at, storytime, name, inbound_source
"""


ORGANIZATION_FETCH = """-- name: organization_fetch \\:one
SELECT id, created_at, updated_at, storytime, name, inbound_source
FROM organizations
WHERE id = %(p1)s
"""


ORGANIZATION_FETCH_ALL = """-- name: organization_fetch_all \\:many
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
WHERE tu.user_id = %(p1)s
"""


PIPELINE_ORGANIZATION_ID_FETCH_ALL = """-- name: pipeline_organization_id_fetch_all \\:many
SELECT id FROM organizations ORDER BY id
"""


RPC_UNEXPIRED_SESSION_FETCH = """-- name: rpc_unexpired_session_fetch \\:one
SELECT id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
FROM sessions
WHERE id = %(p1)s
AND expired_at IS NULL
AND last_seen_at > NOW() - '14 days'::INTERVAL
"""


TEST_ORGANIZATION_CREATE = """-- name: test_organization_create \\:one
INSERT INTO organizations (name, inbound_source)
VALUES (%(p1)s, %(p2)s)
RETURNING id, created_at, updated_at, storytime, name, inbound_source
"""


TEST_ORGANIZATION_USER_CREATE = """-- name: test_organization_user_create \\:one
INSERT INTO organizations_users (user_id, organization_id)
VALUES (%(p1)s, %(p2)s)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, removed_at, removed_by_user
"""


TEST_SESSION_CREATE = """-- name: test_session_create \\:one
INSERT INTO sessions (user_id, organization_id, expired_at, last_seen_at)
VALUES (%(p1)s, %(p2)s, %(p3)s, %(p4)s)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""


TEST_USER_CREATE = """-- name: test_user_create \\:one

INSERT INTO users (name, email, password_hash, signup_step, is_enabled)
VALUES (%(p1)s, %(p2)s, %(p3)s, %(p4)s, %(p5)s)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""


USER_CREATE = """-- name: user_create \\:one
INSERT INTO users (name, email, password_hash, signup_step)
VALUES (%(p1)s, %(p2)s, %(p3)s, %(p4)s)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""


USER_FETCH = """-- name: user_fetch \\:one
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE id = %(p1)s
"""


VAULT_SECRET_CREATE = """-- name: vault_secret_create \\:one
INSERT INTO vaulted_secrets (organization_id, ciphertext)
VALUES (%(p1)s, %(p2)s)
RETURNING id, created_at, updated_at, storytime, organization_id, ciphertext
"""


VAULT_SECRET_DELETE = """-- name: vault_secret_delete \\:exec
DELETE
FROM vaulted_secrets
WHERE id = %(p1)s
"""


VAULT_SECRET_FETCH = """-- name: vault_secret_fetch \\:one
SELECT id, created_at, updated_at, storytime, organization_id, ciphertext
FROM vaulted_secrets
WHERE id = %(p1)s
"""


class AsyncQuerier:
    def __init__(self, conn: psycopg.AsyncConnection[Any]):
        self._conn = conn

    async def authn_linked_organization_fetch(self, *, user_id: str, id: str) -> Optional[models.Organization]:
        row = await (await self._conn.execute(AUTHN_LINKED_ORGANIZATION_FETCH, {"p1": user_id, "p2": id})).fetchone()
        if row is None:
            return None
        return models.Organization(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def authn_most_recently_accessed_organization_fetch(self, *, user_id: str) -> Optional[models.Organization]:
        row = await (await self._conn.execute(AUTHN_MOST_RECENTLY_ACCESSED_ORGANIZATION_FETCH, {"p1": user_id})).fetchone()
        if row is None:
            return None
        return models.Organization(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def authn_session_create(self, *, user_id: str, organization_id: Optional[str]) -> Optional[models.Session]:
        row = await (await self._conn.execute(AUTHN_SESSION_CREATE, {"p1": user_id, "p2": organization_id})).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            user_id=row[4],
            organization_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def authn_session_expire(self, *, id: str) -> None:
        await self._conn.execute(AUTHN_SESSION_EXPIRE, {"p1": id})

    async def authn_session_fetch_by_user(self, *, user_id: str) -> Optional[models.Session]:
        row = await (await self._conn.execute(AUTHN_SESSION_FETCH_BY_USER, {"p1": user_id})).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            user_id=row[4],
            organization_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def authn_user_fetch_by_email(self, *, email: str) -> Optional[models.User]:
        row = await (await self._conn.execute(AUTHN_USER_FETCH_BY_EMAIL, {"p1": email})).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def organization_add_user(self, *, organization_id: str, user_id: str) -> Optional[models.OrganizationsUser]:
        row = await (await self._conn.execute(ORGANIZATION_ADD_USER, {"p1": organization_id, "p2": user_id})).fetchone()
        if row is None:
            return None
        return models.OrganizationsUser(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            user_id=row[4],
            organization_id=row[5],
            removed_at=row[6],
            removed_by_user=row[7],
        )

    async def organization_create(self, *, name: str, inbound_source: str) -> Optional[models.Organization]:
        row = await (await self._conn.execute(ORGANIZATION_CREATE, {"p1": name, "p2": inbound_source})).fetchone()
        if row is None:
            return None
        return models.Organization(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def organization_fetch(self, *, id: str) -> Optional[models.Organization]:
        row = await (await self._conn.execute(ORGANIZATION_FETCH, {"p1": id})).fetchone()
        if row is None:
            return None
        return models.Organization(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def organization_fetch_all(self, *, user_id: str) -> AsyncIterator[models.Organization]:
        cursor = await self._conn.execute(ORGANIZATION_FETCH_ALL, {"p1": user_id})
        async for row in cursor:
            yield models.Organization(
                id=row[0],
                created_at=row[1],
                updated_at=row[2],
                storytime=row[3],
                name=row[4],
                inbound_source=row[5],
            )

    async def pipeline_organization_id_fetch_all(self) -> AsyncIterator[str]:
        cursor = await self._conn.execute(PIPELINE_ORGANIZATION_ID_FETCH_ALL)
        async for row in cursor:
            yield row[0]

    async def rpc_unexpired_session_fetch(self, *, id: str) -> Optional[models.Session]:
        row = await (await self._conn.execute(RPC_UNEXPIRED_SESSION_FETCH, {"p1": id})).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            user_id=row[4],
            organization_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def test_organization_create(self, *, name: str, inbound_source: str) -> Optional[models.Organization]:
        row = await (await self._conn.execute(TEST_ORGANIZATION_CREATE, {"p1": name, "p2": inbound_source})).fetchone()
        if row is None:
            return None
        return models.Organization(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def test_organization_user_create(self, *, user_id: str, organization_id: str) -> Optional[models.OrganizationsUser]:
        row = await (await self._conn.execute(TEST_ORGANIZATION_USER_CREATE, {"p1": user_id, "p2": organization_id})).fetchone()
        if row is None:
            return None
        return models.OrganizationsUser(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            user_id=row[4],
            organization_id=row[5],
            removed_at=row[6],
            removed_by_user=row[7],
        )

    async def test_session_create(self, *, user_id: str, organization_id: Optional[str], expired_at: Optional[datetime.datetime], last_seen_at: datetime.datetime) -> Optional[models.Session]:
        row = await (await self._conn.execute(TEST_SESSION_CREATE, {
            "p1": user_id,
            "p2": organization_id,
            "p3": expired_at,
            "p4": last_seen_at,
        })).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            user_id=row[4],
            organization_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def test_user_create(self, *, name: str, email: str, password_hash: Optional[str], signup_step: str, is_enabled: bool) -> Optional[models.User]:
        row = await (await self._conn.execute(TEST_USER_CREATE, {
            "p1": name,
            "p2": email,
            "p3": password_hash,
            "p4": signup_step,
            "p5": is_enabled,
        })).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def user_create(self, *, name: str, email: str, password_hash: Optional[str], signup_step: str) -> Optional[models.User]:
        row = await (await self._conn.execute(USER_CREATE, {
            "p1": name,
            "p2": email,
            "p3": password_hash,
            "p4": signup_step,
        })).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def user_fetch(self, *, id: str) -> Optional[models.User]:
        row = await (await self._conn.execute(USER_FETCH, {"p1": id})).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def vault_secret_create(self, *, organization_id: str, ciphertext: str) -> Optional[models.VaultedSecret]:
        row = await (await self._conn.execute(VAULT_SECRET_CREATE, {"p1": organization_id, "p2": ciphertext})).fetchone()
        if row is None:
            return None
        return models.VaultedSecret(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            organization_id=row[4],
            ciphertext=row[5],
        )

    async def vault_secret_delete(self, *, id: str) -> None:
        await self._conn.execute(VAULT_SECRET_DELETE, {"p1": id})

    async def vault_secret_fetch(self, *, id: str) -> Optional[models.VaultedSecret]:
        row = await (await self._conn.execute(VAULT_SECRET_FETCH, {"p1": id})).fetchone()
        if row is None:
            return None
        return models.VaultedSecret(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            organization_id=row[4],
            ciphertext=row[5],
        )
