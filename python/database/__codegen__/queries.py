# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models

ORGANIZATIONFETCH = """-- name: OrganizationFetch :one
SELECT id, created_at, updated_at, storytime, name, inbound_source
FROM organizations
WHERE id = $1
"""

async def OrganizationFetch(conn: DBConn, *, id: str) -> models.Organization | None:
    row = (await conn.execute(sqlalchemy.text(ORGANIZATIONFETCH), {"p1": id})).first()
    if row is None:
        return None
    return models.Organization(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

ORGANIZATIONFETCHALL = """-- name: OrganizationFetchAll :many
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
WHERE tu.user_id = $1
"""

async def OrganizationFetchAll(conn: DBConn, *, user_id: str) -> AsyncIterator[models.Organization]:
    result = await conn.execute(sqlalchemy.text(ORGANIZATIONFETCHALL), {"p1": user_id})
    async for row in result:
        yield models.Organization(
            id=row[0],
            created_at=row[1],
            updated_at=row[2],
            storytime=row[3],
            name=row[4],
            inbound_source=row[5],
        )

ORGANIZATIONCREATE = """-- name: OrganizationCreate :one
INSERT INTO organizations (name, inbound_source)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, name, inbound_source
"""

async def OrganizationCreate(conn: DBConn, *, name: str, inbound_source: str) -> models.Organization | None:
    row = (await conn.execute(sqlalchemy.text(ORGANIZATIONCREATE), {"p1": name, "p2": inbound_source})).first()
    if row is None:
        return None
    return models.Organization(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

ORGANIZATIONUSERADD = """-- name: OrganizationUserAdd :one
INSERT INTO organizations_users (organization_id, user_id)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, removed_at, removed_by_user
"""

async def OrganizationUserAdd(conn: DBConn, *, organization_id: str, user_id: str) -> models.OrganizationsUser | None:
    row = (await conn.execute(sqlalchemy.text(ORGANIZATIONUSERADD), {"p1": organization_id, "p2": user_id})).first()
    if row is None:
        return None
    return models.OrganizationsUser(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        removed_at=row[6],
        removed_by_user=row[7],
    )

USERFETCH = """-- name: UserFetch :one
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE id = $1
"""

async def UserFetch(conn: DBConn, *, id: str) -> models.User | None:
    row = (await conn.execute(sqlalchemy.text(USERFETCH), {"p1": id})).first()
    if row is None:
        return None
    return models.User(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

USERCREATE = """-- name: UserCreate :one
INSERT INTO users (name, email, password_hash, signup_step)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""

async def UserCreate(conn: DBConn, *, name: str, email: str, password_hash: str | None, signup_step: str) -> models.User | None:
    row = (await conn.execute(sqlalchemy.text(USERCREATE), {"p1": name, "p2": email, "p3": password_hash, "p4": signup_step})).first()
    if row is None:
        return None
    return models.User(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

AUTHNUSERFETCHBYEMAIL = """-- name: AuthnUserFetchByEmail :one
SELECT id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE email = $1
"""

async def AuthnUserFetchByEmail(conn: DBConn, *, email: str) -> models.User | None:
    row = (await conn.execute(sqlalchemy.text(AUTHNUSERFETCHBYEMAIL), {"p1": email})).first()
    if row is None:
        return None
    return models.User(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

AUTHNSESSIONCREATE = """-- name: AuthnSessionCreate :one
INSERT INTO sessions (user_id, organization_id)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""

async def AuthnSessionCreate(conn: DBConn, *, user_id: str, organization_id: str | None) -> models.Session | None:
    row = (await conn.execute(sqlalchemy.text(AUTHNSESSIONCREATE), {"p1": user_id, "p2": organization_id})).first()
    if row is None:
        return None
    return models.Session(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

AUTHNSESSIONEXPIRE = """-- name: AuthnSessionExpire :exec
UPDATE sessions
SET expired_at = NOW() 
WHERE id = $1
"""

async def AuthnSessionExpire(conn: DBConn, *, id: str) -> None:
    await conn.execute(sqlalchemy.text(AUTHNSESSIONEXPIRE), {"p1": id})

AUTHNLINKEDORGANIZATIONFETCH = """-- name: AuthnLinkedOrganizationFetch :one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
WHERE tu.user_id = $1 AND t.id = $2
"""

async def AuthnLinkedOrganizationFetch(conn: DBConn, *, user_id: str, id: str) -> models.Organization | None:
    row = (await conn.execute(sqlalchemy.text(AUTHNLINKEDORGANIZATIONFETCH), {"p1": user_id, "p2": id})).first()
    if row is None:
        return None
    return models.Organization(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

AUTHNMOSTRECENTLYACCESSEDORGANIZATIONFETCH = """-- name: AuthnMostRecentlyAccessedOrganizationFetch :one
SELECT t.id, t.created_at, t.updated_at, t.storytime, t.name, t.inbound_source
FROM organizations t
JOIN organizations_users tu ON tu.organization_id = t.id
LEFT JOIN sessions s ON s.organization_id = t.id AND s.user_id = tu.user_id
WHERE tu.user_id = $1
ORDER BY s.last_seen_at DESC NULLS LAST, t.id ASC
LIMIT 1
"""

async def AuthnMostRecentlyAccessedOrganizationFetch(conn: DBConn, *, user_id: str) -> models.Organization | None:
    row = (await conn.execute(sqlalchemy.text(AUTHNMOSTRECENTLYACCESSEDORGANIZATIONFETCH), {"p1": user_id})).first()
    if row is None:
        return None
    return models.Organization(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

AUTHNSESSIONFETCHBYUSER = """-- name: AuthnSessionFetchByUser :one
SELECT id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
FROM sessions
WHERE user_id = $1
ORDER BY last_seen_at DESC
LIMIT 1
"""

async def AuthnSessionFetchByUser(conn: DBConn, *, user_id: str) -> models.Session | None:
    row = (await conn.execute(sqlalchemy.text(AUTHNSESSIONFETCHBYUSER), {"p1": user_id})).first()
    if row is None:
        return None
    return models.Session(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

VAULTSECRETCREATE = """-- name: VaultSecretCreate :one
INSERT INTO vaulted_secrets (organization_id, ciphertext)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, organization_id, ciphertext
"""

async def VaultSecretCreate(conn: DBConn, *, organization_id: str, ciphertext: str) -> models.VaultedSecret | None:
    row = (await conn.execute(sqlalchemy.text(VAULTSECRETCREATE), {"p1": organization_id, "p2": ciphertext})).first()
    if row is None:
        return None
    return models.VaultedSecret(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        organization_id=row[4],
        ciphertext=row[5],
    )

VAULTSECRETFETCH = """-- name: VaultSecretFetch :one
SELECT id, created_at, updated_at, storytime, organization_id, ciphertext
FROM vaulted_secrets
WHERE id = $1
"""

async def VaultSecretFetch(conn: DBConn, *, id: str) -> models.VaultedSecret | None:
    row = (await conn.execute(sqlalchemy.text(VAULTSECRETFETCH), {"p1": id})).first()
    if row is None:
        return None
    return models.VaultedSecret(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        organization_id=row[4],
        ciphertext=row[5],
    )

VAULTSECRETDELETE = """-- name: VaultSecretDelete :exec
DELETE
FROM vaulted_secrets
WHERE id = $1
"""

async def VaultSecretDelete(conn: DBConn, *, id: str) -> None:
    await conn.execute(sqlalchemy.text(VAULTSECRETDELETE), {"p1": id})

RPCUNEXPIREDSESSIONFETCH = """-- name: RpcUnexpiredSessionFetch :one
SELECT id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
FROM sessions
WHERE id = $1
AND expired_at IS NULL
AND last_seen_at > NOW() - '14 days'::INTERVAL
"""

async def RpcUnexpiredSessionFetch(conn: DBConn, *, id: str) -> models.Session | None:
    row = (await conn.execute(sqlalchemy.text(RPCUNEXPIREDSESSIONFETCH), {"p1": id})).first()
    if row is None:
        return None
    return models.Session(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

PIPELINEORGANIZATIONIDFETCHALL = """-- name: PipelineOrganizationIDFetchAll :many
SELECT id FROM organizations ORDER BY id
"""

async def PipelineOrganizationIDFetchAll(conn: DBConn) -> AsyncIterator[models.Organization]:
    result = await conn.execute(sqlalchemy.text(PIPELINEORGANIZATIONIDFETCHALL), {})
    async for row in result:
        yield models.Organization(
            id=row[0],
        )

TESTUSERCREATE = """-- name: TestUserCreate :one

INSERT INTO users (name, email, password_hash, signup_step, is_enabled)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""

async def TestUserCreate(conn: DBConn, *, name: str, email: str, password_hash: str | None, signup_step: str, is_enabled: bool) -> models.User | None:
    row = (await conn.execute(sqlalchemy.text(TESTUSERCREATE), {"p1": name, "p2": email, "p3": password_hash, "p4": signup_step, "p5": is_enabled})).first()
    if row is None:
        return None
    return models.User(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

TESTORGANIZATIONCREATE = """-- name: TestOrganizationCreate :one
INSERT INTO organizations (name, inbound_source)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, name, inbound_source
"""

async def TestOrganizationCreate(conn: DBConn, *, name: str, inbound_source: str) -> models.Organization | None:
    row = (await conn.execute(sqlalchemy.text(TESTORGANIZATIONCREATE), {"p1": name, "p2": inbound_source})).first()
    if row is None:
        return None
    return models.Organization(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

TESTORGANIZATIONUSERCREATE = """-- name: TestOrganizationUserCreate :one
INSERT INTO organizations_users (user_id, organization_id)
VALUES ($1, $2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, removed_at, removed_by_user
"""

async def TestOrganizationUserCreate(conn: DBConn, *, user_id: str, organization_id: str) -> models.OrganizationsUser | None:
    row = (await conn.execute(sqlalchemy.text(TESTORGANIZATIONUSERCREATE), {"p1": user_id, "p2": organization_id})).first()
    if row is None:
        return None
    return models.OrganizationsUser(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        removed_at=row[6],
        removed_by_user=row[7],
    )

TESTSESSIONCREATE = """-- name: TestSessionCreate :one
INSERT INTO sessions (user_id, organization_id, expired_at, last_seen_at)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""

async def TestSessionCreate(conn: DBConn, *, user_id: str, organization_id: str | None, expired_at: Any | None, last_seen_at: Any) -> models.Session | None:
    row = (await conn.execute(sqlalchemy.text(TESTSESSIONCREATE), {"p1": user_id, "p2": organization_id, "p3": expired_at, "p4": last_seen_at})).first()
    if row is None:
        return None
    return models.Session(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

