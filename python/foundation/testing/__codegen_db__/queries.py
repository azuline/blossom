# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import Any, AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen_db__ import models
from foundation.observability.errors import NotFoundError

TEST_USER_CREATE = r"""-- name: test_user_create \:one
INSERT INTO users (name, email, password_hash, signup_step, is_enabled)
VALUES (:p1, :p2, :p3, :p4, :p5)
RETURNING id, created_at, updated_at, storytime, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""

async def query_test_user_create(conn: DBConn, *, name: str, email: str, password_hash: str | None, signup_step: str, is_enabled: bool) -> models.UserModel:
    row = (await conn.execute(sqlalchemy.text(TEST_USER_CREATE), {"p1": name, "p2": email, "p3": password_hash, "p4": signup_step, "p5": is_enabled})).first()
    if row is None:
        raise NotFoundError(resource="user", key_name="name", key_value=str(name))
    return models.UserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        email=row[5],
        password_hash=row[6],
        signup_step=row[7],
        is_enabled=row[8],
        last_visited_at=row[9],
    )

TEST_ORGANIZATION_CREATE = r"""-- name: test_organization_create \:one
INSERT INTO organizations (name, inbound_source)
VALUES (:p1, :p2)
RETURNING id, created_at, updated_at, storytime, name, inbound_source
"""

async def query_test_organization_create(conn: DBConn, *, name: str, inbound_source: str) -> models.OrganizationModel:
    row = (await conn.execute(sqlalchemy.text(TEST_ORGANIZATION_CREATE), {"p1": name, "p2": inbound_source})).first()
    if row is None:
        raise NotFoundError(resource="organization", key_name="name", key_value=str(name))
    return models.OrganizationModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        name=row[4],
        inbound_source=row[5],
    )

TEST_ORGANIZATION_USER_CREATE = r"""-- name: test_organization_user_create \:one
INSERT INTO organizations_users (user_id, organization_id)
VALUES (:p1, :p2)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, removed_at, removed_by_user
"""

async def query_test_organization_user_create(conn: DBConn, *, user_id: str, organization_id: str) -> models.OrganizationsUserModel:
    row = (await conn.execute(sqlalchemy.text(TEST_ORGANIZATION_USER_CREATE), {"p1": user_id, "p2": organization_id})).first()
    if row is None:
        raise NotFoundError(resource="organizationsuser", key_name="user_id", key_value=str(user_id))
    return models.OrganizationsUserModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        removed_at=row[6],
        removed_by_user=row[7],
    )

TEST_SESSION_CREATE = r"""-- name: test_session_create \:one
INSERT INTO sessions (user_id, organization_id, expired_at, last_seen_at)
VALUES (:p1, :p2, :p3, :p4)
RETURNING id, created_at, updated_at, storytime, user_id, organization_id, last_seen_at, expired_at
"""

async def query_test_session_create(conn: DBConn, *, user_id: str, organization_id: str | None, expired_at: Any | None, last_seen_at: Any) -> models.SessionModel:
    row = (await conn.execute(sqlalchemy.text(TEST_SESSION_CREATE), {"p1": user_id, "p2": organization_id, "p3": expired_at, "p4": last_seen_at})).first()
    if row is None:
        raise NotFoundError(resource="session", key_name="user_id", key_value=str(user_id))
    return models.SessionModel(
        id=row[0],
        created_at=row[1],
        updated_at=row[2],
        storytime=row[3],
        user_id=row[4],
        organization_id=row[5],
        last_seen_at=row[6],
        expired_at=row[7],
    )

