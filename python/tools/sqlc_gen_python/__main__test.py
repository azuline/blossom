"""Tests for sqlc_gen_python tool."""

from click.testing import CliRunner

from tools.sqlc_gen_python.__main__ import generate_models, generate_queries, main
from tools.sqlc_gen_python.proto import Catalog, Column, GenerateRequest, GenerateResponse, Identifier, Parameter, Query, Schema, Settings, Table


def test_protobuf_serialization_roundtrip():
    """Test that we can serialize and deserialize protobuf messages correctly."""
    # Create a sample GenerateRequest
    request = GenerateRequest(
        sqlc_version="1.0.0",
        settings=Settings(version="1.0.0", engine="postgresql"),
        catalog=Catalog(
            name="test_db",
            default_schema="public",
            schemas=[
                Schema(
                    name="public",
                    tables=[
                        Table(
                            rel=Identifier(name="users", schema="public"),
                            columns=[Column(name="id", not_null=True, type=Identifier(name="bigint")), Column(name="name", not_null=True, type=Identifier(name="text"))],
                        )
                    ],
                )
            ],
        ),
        queries=[Query(name="get_user", text="SELECT id, name FROM users WHERE id = $1", cmd=":one")],
    )

    # Test serialization
    serialized = bytes(request)
    assert len(serialized) > 0

    # Test deserialization
    deserialized = GenerateRequest().parse(serialized)

    # Verify the data was preserved
    assert deserialized.sqlc_version == "1.0.0"
    assert deserialized.settings.version == "1.0.0"
    assert deserialized.catalog.name == "test_db"
    assert len(deserialized.catalog.schemas) == 1
    assert deserialized.catalog.schemas[0].name == "public"
    assert len(deserialized.catalog.schemas[0].tables) == 1
    assert deserialized.catalog.schemas[0].tables[0].rel.name == "users"
    assert len(deserialized.catalog.schemas[0].tables[0].columns) == 2
    assert len(deserialized.queries) == 1
    assert deserialized.queries[0].name == "get_user"


def test_cli_basic_functionality():
    """Test that the CLI tool can handle basic protobuf input/output."""
    runner = CliRunner()

    # Create a minimal GenerateRequest with empty catalog and queries
    request = GenerateRequest(sqlc_version="1.0.0", settings=Settings(version="1.0.0", engine="postgresql"), catalog=Catalog(name="test", schemas=[]))

    # Serialize request
    input_data = bytes(request)

    # Run the CLI tool
    result = runner.invoke(main, input=input_data)

    # Check that it ran without errors
    assert result.exit_code == 0

    # Parse the output as a GenerateResponse
    response = GenerateResponse().parse(result.stdout_bytes)

    # Verify response structure and exact content
    assert len(response.files) == 2
    assert response.files[0].name == "models.py"
    assert response.files[1].name == "queries.py"

    # Check exact models.py content (empty catalog should produce minimal output)
    expected_models = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

"""
    assert response.files[0].contents.decode("utf-8") == expected_models

    # Check exact queries.py content (empty queries should produce minimal output)
    expected_queries = """\
# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models

"""
    assert response.files[1].contents.decode("utf-8") == expected_queries


def test_cli_with_service_method():
    """Test that the CLI tool handles the gRPC service method argument correctly."""
    runner = CliRunner()

    request = GenerateRequest(sqlc_version="1.0.0", settings=Settings(version="1.0.0", engine="postgresql"), catalog=Catalog(name="test", schemas=[]))
    input_data = bytes(request)
    result = runner.invoke(main, ["/plugin.CodegenService/Generate"], input=input_data)
    assert result.exit_code == 0

    response = GenerateResponse().parse(result.stdout_bytes)
    assert len(response.files) == 2
    assert response.files[0].name == "models.py"
    assert response.files[1].name == "queries.py"


def test_model_generation():
    """Test database model dataclass generation."""
    # Create a sample catalog with a table
    catalog = Catalog(
        name="test_db",
        schemas=[
            Schema(
                name="public",
                tables=[
                    Table(
                        rel=Identifier(name="users", schema="public"),
                        columns=[
                            Column(name="id", not_null=True, type=Identifier(name="bigint")),
                            Column(name="name", not_null=True, type=Identifier(name="text")),
                            Column(name="email", not_null=False, type=Identifier(name="text")),
                            Column(name="created_at", not_null=True, type=Identifier(name="timestamptz")),
                            Column(name="tags", not_null=False, is_array=True, type=Identifier(name="text")),
                        ],
                    )
                ],
            )
        ],
    )

    # Generate models
    models_code = generate_models(catalog)

    # Assert exact expected output (de-pluralized: users -> User)
    expected_code = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

@dataclasses.dataclass(slots=True)
class User:
    id: int
    name: str
    email: str | None
    created_at: datetime.datetime
    tags: list[str] | None

"""
    assert models_code == expected_code


def test_query_generation():
    """Test query function generation."""
    # Create sample queries
    queries = [
        Query(
            name="get_user",
            text="SELECT id, name, email FROM users WHERE id = $1",
            cmd=":one",
            params=[Parameter(number=1, column=Column(name="id", not_null=True, type=Identifier(name="bigint")))],
            columns=[
                Column(name="id", not_null=True, type=Identifier(name="bigint"), table=Identifier(name="users")),
                Column(name="name", not_null=True, type=Identifier(name="text"), table=Identifier(name="users")),
                Column(name="email", not_null=False, type=Identifier(name="text"), table=Identifier(name="users")),
            ],
        ),
        Query(
            name="list_users",
            text="SELECT id, name, email FROM users",
            cmd=":many",
            columns=[
                Column(name="id", not_null=True, type=Identifier(name="bigint"), table=Identifier(name="users")),
                Column(name="name", not_null=True, type=Identifier(name="text"), table=Identifier(name="users")),
                Column(name="email", not_null=False, type=Identifier(name="text"), table=Identifier(name="users")),
            ],
        ),
        Query(
            name="delete_user",
            text="DELETE FROM users WHERE id = $1",
            cmd=":exec",
            params=[Parameter(number=1, column=Column(name="id", not_null=True, type=Identifier(name="bigint")))],
        ),
    ]

    # Generate queries
    queries_code = generate_queries(queries)

    # Assert exact expected output
    expected_code = '''\
# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models

GET_USER = """-- name: get_user :one
SELECT id, name, email FROM users WHERE id = $1
"""

async def get_user(conn: DBConn, *, id: int) -> models.User | None:
    row = (await conn.execute(sqlalchemy.text(GET_USER), {"p1": id})).first()
    if row is None:
        return None
    return models.User(
        id=row[0],
        name=row[1],
        email=row[2],
    )

LIST_USERS = """-- name: list_users :many
SELECT id, name, email FROM users
"""

async def list_users(conn: DBConn) -> AsyncIterator[models.User]:
    result = await conn.execute(sqlalchemy.text(LIST_USERS), {})
    async for row in result:
        yield models.User(
            id=row[0],
            name=row[1],
            email=row[2],
        )

DELETE_USER = """-- name: delete_user :exec
DELETE FROM users WHERE id = $1
"""

async def delete_user(conn: DBConn, *, id: int) -> None:
    await conn.execute(sqlalchemy.text(DELETE_USER), {"p1": id})

'''
    assert queries_code == expected_code


def test_schema_filtering_and_depluralization():
    """Test that only public schema tables are included and names are de-pluralized."""
    # Create a catalog with both public and non-public schemas
    catalog = Catalog(
        name="test_db",
        schemas=[
            Schema(
                name="public",
                tables=[
                    Table(
                        rel=Identifier(name="users", schema="public"),
                        columns=[Column(name="id", not_null=True, type=Identifier(name="bigint"))],
                    ),
                    Table(
                        rel=Identifier(name="companies", schema="public"),
                        columns=[Column(name="id", not_null=True, type=Identifier(name="bigint"))],
                    ),
                ],
            ),
            Schema(
                name="internal",
                tables=[
                    Table(
                        rel=Identifier(name="logs", schema="internal"),
                        columns=[Column(name="id", not_null=True, type=Identifier(name="bigint"))],
                    )
                ],
            ),
        ],
    )

    # Generate models
    models_code = generate_models(catalog)

    # Assert that only public schema tables are included and names are de-pluralized
    expected_code = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

@dataclasses.dataclass(slots=True)
class User:
    id: int

@dataclasses.dataclass(slots=True)
class Company:
    id: int

"""
    assert models_code == expected_code
