"""Tests for sqlc_gen_python tool."""

import asyncio

import sqlalchemy
from click.testing import CliRunner

from database.conn import connect_db_admin
from tools.sqlc_gen_python.__main__ import generate_enums, generate_models, generate_queries, main
from tools.sqlc_gen_python.proto import Catalog, Column, GenerateRequest, GenerateResponse, Identifier, Parameter, Query, Schema, Settings, Table


def test_protobuf_serialization_roundtrip():
    """Test that we can serialize and deserialize protobuf messages correctly."""
    # Create a sample GenerateRequest
    request = GenerateRequest(
        sqlc_version="1.0.0",
        settings=Settings(version="1.0.0", engine="postgresql"),
        catalog=Catalog(
            name="test_db",
            default_schema="public",
            schemas=[
                Schema(
                    name="public",
                    tables=[
                        Table(
                            rel=Identifier(name="users", schema="public"),
                            columns=[Column(name="id", not_null=True, type=Identifier(name="bigint")), Column(name="name", not_null=True, type=Identifier(name="text"))],
                        )
                    ],
                )
            ],
        ),
        queries=[Query(name="get_user", text="SELECT id, name FROM users WHERE id = $1", cmd=":one")],
    )

    # Test serialization
    serialized = bytes(request)
    assert len(serialized) > 0

    # Test deserialization
    deserialized = GenerateRequest().parse(serialized)

    # Verify the data was preserved
    assert deserialized.sqlc_version == "1.0.0"
    assert deserialized.settings.version == "1.0.0"
    assert deserialized.catalog.name == "test_db"
    assert len(deserialized.catalog.schemas) == 1
    assert deserialized.catalog.schemas[0].name == "public"
    assert len(deserialized.catalog.schemas[0].tables) == 1
    assert deserialized.catalog.schemas[0].tables[0].rel.name == "users"
    assert len(deserialized.catalog.schemas[0].tables[0].columns) == 2
    assert len(deserialized.queries) == 1
    assert deserialized.queries[0].name == "get_user"


def test_cli_basic_functionality():
    """Test that the CLI tool can handle basic protobuf input/output."""
    runner = CliRunner()

    # Create a minimal GenerateRequest with empty catalog and queries
    request = GenerateRequest(sqlc_version="1.0.0", settings=Settings(version="1.0.0", engine="postgresql"), catalog=Catalog(name="test", schemas=[]))

    # Serialize request
    input_data = bytes(request)

    # Run the CLI tool with the expected service method
    result = runner.invoke(main, ["/plugin.CodegenService/Generate"], input=input_data)

    # Check that it ran without errors
    assert result.exit_code == 0

    # Parse the output as a GenerateResponse
    response = GenerateResponse().parse(result.stdout_bytes)

    # Verify response structure and exact content
    assert len(response.files) == 2
    assert response.files[0].name == "models.py"
    assert response.files[1].name == "queries.py"

    # Check exact models.py content (empty catalog should produce minimal output)
    expected_models = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

"""
    assert response.files[0].contents.decode("utf-8") == expected_models

    # Check exact queries.py content (empty queries should produce minimal output)
    expected_queries = """\
# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models
from foundation.observability.errors import NotFoundError

"""
    assert response.files[1].contents.decode("utf-8") == expected_queries


def test_cli_with_service_method():
    """Test that the CLI tool handles the gRPC service method argument correctly."""
    runner = CliRunner()

    request = GenerateRequest(sqlc_version="1.0.0", settings=Settings(version="1.0.0", engine="postgresql"), catalog=Catalog(name="test", schemas=[]))
    input_data = bytes(request)
    result = runner.invoke(main, ["/plugin.CodegenService/Generate"], input=input_data)
    assert result.exit_code == 0

    response = GenerateResponse().parse(result.stdout_bytes)
    assert len(response.files) == 2
    assert response.files[0].name == "models.py"
    assert response.files[1].name == "queries.py"


async def test_model_generation():
    """Test database model dataclass generation."""
    # Create a sample catalog with a table
    catalog = Catalog(
        name="test_db",
        schemas=[
            Schema(
                name="public",
                tables=[
                    Table(
                        rel=Identifier(name="users", schema="public"),
                        columns=[
                            Column(name="id", not_null=True, type=Identifier(name="bigint")),
                            Column(name="name", not_null=True, type=Identifier(name="text")),
                            Column(name="email", not_null=False, type=Identifier(name="text")),
                            Column(name="created_at", not_null=True, type=Identifier(name="timestamptz")),
                            Column(name="tags", not_null=False, is_array=True, type=Identifier(name="text")),
                            Column(name="metadata", not_null=False, type=Identifier(name="jsonb")),
                        ],
                    )
                ],
            )
        ],
    )

    # Generate models
    models_code = await generate_models(catalog)

    # Assert exact expected output (de-pluralized: users -> User)
    expected_code = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

@dataclasses.dataclass(slots=True)
class User:
    id: int
    name: str
    email: str | None
    created_at: datetime.datetime
    tags: list[str] | None
    metadata: dict[str, Any] | None

"""
    assert models_code == expected_code


def test_query_generation():
    """Test query function generation."""
    # Create sample queries
    queries = [
        Query(
            name="get_user",
            text="SELECT id, name, email FROM users WHERE id = $1",
            cmd=":one",
            params=[Parameter(number=1, column=Column(name="id", not_null=True, type=Identifier(name="bigint")))],
            columns=[
                Column(name="id", not_null=True, type=Identifier(name="bigint"), table=Identifier(name="users")),
                Column(name="name", not_null=True, type=Identifier(name="text"), table=Identifier(name="users")),
                Column(name="email", not_null=False, type=Identifier(name="text"), table=Identifier(name="users")),
            ],
        ),
        Query(
            name="list_users",
            text="SELECT id, name, email FROM users",
            cmd=":many",
            columns=[
                Column(name="id", not_null=True, type=Identifier(name="bigint"), table=Identifier(name="users")),
                Column(name="name", not_null=True, type=Identifier(name="text"), table=Identifier(name="users")),
                Column(name="email", not_null=False, type=Identifier(name="text"), table=Identifier(name="users")),
            ],
        ),
        Query(
            name="delete_user",
            text="DELETE FROM users WHERE id = $1",
            cmd=":exec",
            params=[Parameter(number=1, column=Column(name="id", not_null=True, type=Identifier(name="bigint")))],
        ),
    ]

    # Generate queries
    queries_code = generate_queries(queries)

    # Assert exact expected output
    expected_code = '''\
# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models
from foundation.observability.errors import NotFoundError

GET_USER = """-- name: get_user :one
SELECT id, name, email FROM users WHERE id = $1
"""

async def get_user(conn: DBConn, *, id: int) -> models.User:
    row = (await conn.execute(sqlalchemy.text(GET_USER), {"p1": id})).first()
    if row is None:
        raise NotFoundError(resource="user", key_name="id", key_value=str(id))
    return models.User(
        id=row[0],
        name=row[1],
        email=row[2],
    )

LIST_USERS = """-- name: list_users :many
SELECT id, name, email FROM users
"""

async def list_users(conn: DBConn) -> AsyncIterator[models.User]:
    result = await conn.execute(sqlalchemy.text(LIST_USERS), {})
    async for row in result:
        yield models.User(
            id=row[0],
            name=row[1],
            email=row[2],
        )

DELETE_USER = """-- name: delete_user :exec
DELETE FROM users WHERE id = $1
"""

async def delete_user(conn: DBConn, *, id: int) -> None:
    await conn.execute(sqlalchemy.text(DELETE_USER), {"p1": id})

'''
    assert queries_code == expected_code


async def test_schema_filtering_and_depluralization():
    """Test that only public schema tables are included and names are de-pluralized."""
    # Create a catalog with both public and non-public schemas
    catalog = Catalog(
        name="test_db",
        schemas=[
            Schema(
                name="public",
                tables=[
                    Table(
                        rel=Identifier(name="users", schema="public"),
                        columns=[Column(name="id", not_null=True, type=Identifier(name="bigint"))],
                    ),
                    Table(
                        rel=Identifier(name="companies", schema="public"),
                        columns=[Column(name="id", not_null=True, type=Identifier(name="bigint"))],
                    ),
                ],
            ),
            Schema(
                name="internal",
                tables=[
                    Table(
                        rel=Identifier(name="logs", schema="internal"),
                        columns=[Column(name="id", not_null=True, type=Identifier(name="bigint"))],
                    )
                ],
            ),
        ],
    )

    # Generate models
    models_code = await generate_models(catalog)

    # Assert that only public schema tables are included and names are de-pluralized
    expected_code = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

@dataclasses.dataclass(slots=True)
class User:
    id: int

@dataclasses.dataclass(slots=True)
class Company:
    id: int

"""
    assert models_code == expected_code


async def test_enum_filtering():
    """Test that _enum tables are excluded from regular model generation."""
    # Create a catalog with both regular and enum tables
    catalog = Catalog(
        name="test_db",
        schemas=[
            Schema(
                name="public",
                tables=[
                    Table(
                        rel=Identifier(name="users", schema="public"),
                        columns=[Column(name="id", not_null=True, type=Identifier(name="bigint"))],
                    ),
                    Table(
                        rel=Identifier(name="status_enum", schema="public"),
                        columns=[Column(name="value", not_null=True, type=Identifier(name="text"))],
                    ),
                ],
            ),
        ],
    )

    # Generate models - should only include non-enum tables
    models_code = await generate_models(catalog)

    # Assert that only the users table is included (not status_enum)
    # But since there's an enum table present, it should include the enum import
    expected_models = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

from database.__codegen__ import enums
@dataclasses.dataclass(slots=True)
class User:
    id: int

"""
    assert models_code == expected_models

    # Also test enum generation by creating a test enum table
    # Create a test enum table and populate it
    async def setup_and_test_enums():
        async with connect_db_admin() as conn:
            # Create the test enum table
            await conn.execute(sqlalchemy.text("CREATE TABLE IF NOT EXISTS status_enum (value TEXT PRIMARY KEY)"))

            # Insert test values
            await conn.execute(sqlalchemy.text("DELETE FROM status_enum"))  # Clean any existing data
            await conn.execute(sqlalchemy.text("INSERT INTO status_enum (value) VALUES ('active'), ('inactive'), ('pending')"))

            # Test with a catalog that references this enum table
            enum_catalog = Catalog(
                name="test_db",
                schemas=[
                    Schema(
                        name="public",
                        tables=[
                            Table(
                                rel=Identifier(name="status_enum", schema="public"),
                                columns=[Column(name="value", not_null=True, type=Identifier(name="text"))],
                            ),
                        ],
                    ),
                ],
            )

            # Generate enums - should now find our test data
            enums_code = await generate_enums(enum_catalog)

            # Clean up the test table
            await conn.execute(sqlalchemy.text("DROP TABLE IF EXISTS status_enum"))

            return enums_code

    enums_code = asyncio.run(setup_and_test_enums())

    # Verify the generated enum code
    expected_enums = """# Code generated by sqlc. DO NOT EDIT.
from typing import Literal

# Generated from status_enum table
type StatusEnum = Literal["active", "inactive", "pending"]
STATUS_ENUM_VALUES = ['active', 'inactive', 'pending']

"""
    assert enums_code == expected_enums


async def test_enum_foreign_key_mapping():
    """Test that columns with foreign keys to enum tables use enum types."""
    # Create a catalog with an enum table and a table that references it
    catalog = Catalog(
        name="test_db",
        schemas=[
            Schema(
                name="public",
                tables=[
                    Table(
                        rel=Identifier(name="status_enum", schema="public"),
                        columns=[Column(name="value", not_null=True, type=Identifier(name="text"))],
                    ),
                    Table(
                        rel=Identifier(name="users", schema="public"),
                        columns=[
                            Column(name="id", not_null=True, type=Identifier(name="bigint")),
                            Column(name="name", not_null=True, type=Identifier(name="text")),
                            Column(name="status", not_null=True, type=Identifier(name="text")),  # FK to status_enum
                        ],
                    ),
                ],
            ),
        ],
    )

    # Generate models
    models_code = await generate_models(catalog)

    # Should include enum import and use StatusEnum type
    expected_models = """# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

from database.__codegen__ import enums
@dataclasses.dataclass(slots=True)
class User:
    id: int
    name: str
    status: enums.StatusEnum

"""
    assert models_code == expected_models
