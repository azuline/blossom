#!/usr/bin/env python3
"""SQLc Python code generation plugin."""

import sys

import click

from tools.sqlc_gen_python.proto import Catalog, Column, File, GenerateRequest, GenerateResponse, Parameter, Query

# PostgreSQL to Python type mapping
POSTGRES_TO_PYTHON_TYPES = {
    "text": "str",
    "varchar": "str",
    "char": "str",
    "bpchar": "str",
    "timestamptz": "datetime.datetime",
    "timestamp": "datetime.datetime",
    "date": "datetime.date",
    "time": "datetime.time",
    "timetz": "datetime.time",
    "interval": "datetime.timedelta",
    "boolean": "bool",
    "bool": "bool",
    "jsonb": "Any",
    "json": "Any",
    "bigint": "int",
    "int8": "int",
    "integer": "int",
    "int4": "int",
    "smallint": "int",
    "int2": "int",
    "serial": "int",
    "bigserial": "int",
    "real": "float",
    "float4": "float",
    "double precision": "float",
    "float8": "float",
    "numeric": "float",
    "decimal": "float",
    "money": "float",
    "uuid": "str",
    "bytea": "bytes",
    "inet": "str",
    "cidr": "str",
    "macaddr": "str",
    "point": "str",
    "line": "str",
    "lseg": "str",
    "box": "str",
    "path": "str",
    "polygon": "str",
    "circle": "str",
}


def map_postgres_type_to_python(column: Column) -> str:
    """Convert PostgreSQL column type to Python type annotation."""
    # Get the base type name
    type_name = column.type.name.lower()

    # Handle array types
    if column.is_array or column.array_dims > 0:
        base_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")
        python_type = f"list[{base_type}]"
    else:
        python_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")

    # Handle nullable types
    if not column.not_null:
        python_type = f"{python_type} | None"

    return python_type


def deserialize_request() -> GenerateRequest:
    """Read and deserialize GenerateRequest from stdin."""
    data = sys.stdin.buffer.read()
    return GenerateRequest().parse(data)


def serialize_response(response: GenerateResponse) -> None:
    """Serialize and write GenerateResponse to stdout."""
    data = bytes(response)
    sys.stdout.buffer.write(data)


def generate_models(catalog: Catalog) -> str:
    """Generate Python dataclass models from database catalog."""
    content = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

"""

    # Generate dataclass for each table
    for schema in catalog.schemas:
        for table in schema.tables:
            # Generate the dataclass
            class_name = _to_pascal_case(table.rel.name)
            content += f"""\
@dataclasses.dataclass(slots=True)
class {class_name}:
"""

            # Generate fields for each column
            for column in table.columns:
                python_type = map_postgres_type_to_python(column)
                content += f"    {column.name}: {python_type}\n"

            content += "\n"  # Empty line after each class

    return content


def _to_pascal_case(snake_str: str) -> str:
    """Convert snake_case to PascalCase."""
    return "".join(word.capitalize() for word in snake_str.split("_"))


def generate_queries(queries: list[Query]) -> str:
    """Generate Python query functions from SQLc queries."""
    content = """\
# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models

"""

    # Generate query constants and functions
    for query in queries:
        # Generate SQL constant
        constant_name = query.name.upper()
        content += f"""\
{constant_name} = \"\"\"-- name: {query.name} {query.cmd}
{query.text}
\"\"\"

"""

        # Generate function signature
        func_name = query.name
        params = _generate_function_parameters(query.params)
        return_type = _generate_return_type(query)

        content += f"async def {func_name}(conn: DBConn{params}) -> {return_type}:\n"

        # Generate function body
        content += _generate_function_body(query)
        content += "\n"

    return content


def _generate_function_parameters(params: list[Parameter]) -> str:
    """Generate function parameters from query parameters."""
    if not params:
        return ""

    param_strs = []
    for param in params:
        param_name = param.column.name if param.column.name else f"p{param.number}"
        param_type = map_postgres_type_to_python(param.column)
        param_strs.append(f"{param_name}: {param_type}")

    return ", *, " + ", ".join(param_strs)


def _generate_return_type(query: Query) -> str:
    """Generate return type annotation for query function."""
    if query.cmd == ":exec":
        return "None"
    elif query.cmd == ":one":
        if query.columns:
            model_name = _infer_model_name(query)
            return f"models.{model_name} | None"
        else:
            return "Any | None"
    elif query.cmd == ":many":
        if query.columns:
            model_name = _infer_model_name(query)
            return f"AsyncIterator[models.{model_name}]"
        else:
            return "AsyncIterator[Any]"
    else:
        return "Any"


def _infer_model_name(query: Query) -> str:
    """Infer model name from query columns or table."""
    # Try to get from insert_into_table first
    if query.insert_into_table and query.insert_into_table.name:
        return _to_pascal_case(query.insert_into_table.name)

    # Try to infer from first column's table
    for column in query.columns:
        if column.table and column.table.name:
            return _to_pascal_case(column.table.name)

    # Fallback: use query name
    return _to_pascal_case(query.name.replace("_", ""))


def _generate_function_body(query: Query) -> str:
    """Generate function body for query execution."""
    # Build parameter mapping
    if query.params:
        param_dict_items = []
        for param in query.params:
            param_name = param.column.name if param.column.name else f"p{param.number}"
            param_dict_items.append(f'"p{param.number}": {param_name}')
        param_dict = "{" + ", ".join(param_dict_items) + "}"
    else:
        param_dict = "{}"

    if query.cmd == ":exec":
        return f"    await conn.execute(sqlalchemy.text({query.name.upper()}), {param_dict})\n"
    elif query.cmd == ":one":
        content = f"""\
    row = (await conn.execute(sqlalchemy.text({query.name.upper()}), {param_dict})).first()
    if row is None:
        return None
"""

        if query.columns:
            model_name = _infer_model_name(query)
            content += f"    return models.{model_name}(\n"
            for i, column in enumerate(query.columns):
                content += f"        {column.name}=row[{i}],\n"
            content += "    )\n"
        else:
            content += "    return row\n"

        return content
    elif query.cmd == ":many":
        content = f"""\
    result = await conn.execute(sqlalchemy.text({query.name.upper()}), {param_dict})
    async for row in result:
"""

        if query.columns:
            model_name = _infer_model_name(query)
            content += f"""\
        yield models.{model_name}(
"""
            for i, column in enumerate(query.columns):
                content += f"            {column.name}=row[{i}],\n"
            content += "        )\n"
        else:
            content += "        yield row\n"

        return content

    return ""


@click.command()
def main() -> None:
    """SQLc Python code generation plugin main entry point."""
    try:
        # Deserialize request from stdin
        request = deserialize_request()

        # Generate models and queries
        models_content = generate_models(request.catalog)
        queries_content = generate_queries(request.queries)

        # Create response with generated files
        response = GenerateResponse()

        # Add models file
        models_file = File(name="models.py", contents=models_content.encode("utf-8"))
        response.files.append(models_file)

        # Add queries file
        queries_file = File(name="queries.py", contents=queries_content.encode("utf-8"))
        response.files.append(queries_file)

        # Serialize response to stdout
        serialize_response(response)

    except Exception as e:
        # Write error to stderr and exit with non-zero code
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
