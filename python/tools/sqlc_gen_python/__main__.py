#!/usr/bin/env python3
"""SQLc Python code generation plugin."""

import asyncio
import sys

import click
import jinja2
import sqlalchemy

from database.conn import connect_db_admin
from tools.sqlc_gen_python.proto import Catalog, Column, File, GenerateRequest, GenerateResponse, Parameter, Query

# Jinja templates for code generation
MODELS_TEMPLATE = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

{% if has_enums -%}
from database.__codegen__ import enums
{% endif -%}

{% for table in tables -%}
@dataclasses.dataclass(slots=True)
class {{ table.class_name }}:
{%- for column in table.columns %}
    {{ column.name }}: {{ column.python_type }}
{%- endfor %}

{% endfor -%}
"""

QUERIES_TEMPLATE = '''\
# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models
from foundation.observability.errors import NotFoundError

{% for query in queries -%}
{{ query.constant_name }} = """-- name: {{ query.name }} {{ query.cmd }}
{{ query.text }}
"""

async def {{ query.name }}(conn: DBConn{{ query.params_signature }}) -> {{ query.return_type }}:
{%- if query.cmd == ":exec" %}
    await conn.execute(sqlalchemy.text({{ query.constant_name }}), {{ query.param_dict }})
{%- elif query.cmd == ":one" %}
    row = (await conn.execute(sqlalchemy.text({{ query.constant_name }}), {{ query.param_dict }})).first()
    if row is None:
        raise NotFoundError({{ query.error_params }})
{%- if query.columns %}
    return models.{{ query.model_name }}(
{%- for column in query.columns %}
        {{ column.name }}=row[{{ loop.index0 }}],
{%- endfor %}
    )
{%- else %}
    return row
{%- endif %}
{%- elif query.cmd == ":many" %}
    result = await conn.execute(sqlalchemy.text({{ query.constant_name }}), {{ query.param_dict }})
    async for row in result:
{%- if query.columns %}
        yield models.{{ query.model_name }}(
{%- for column in query.columns %}
            {{ column.name }}=row[{{ loop.index0 }}],
{%- endfor %}
        )
{%- else %}
        yield row
{%- endif %}
{%- endif %}

{% endfor -%}
'''

ENUMS_TEMPLATE = """\
# Code generated by sqlc. DO NOT EDIT.
from typing import Literal

{% for enum in enums -%}
# Generated from {{ enum.table_name }} table
type {{ enum.type_name }} = Literal[{{ enum.literal_values }}]
{{ enum.values_name }} = {{ enum.values_list }}

{% endfor -%}
"""


# PostgreSQL to Python type mapping
POSTGRES_TO_PYTHON_TYPES = {
    "text": "str",
    "varchar": "str",
    "char": "str",
    "bpchar": "str",
    "timestamptz": "datetime.datetime",
    "timestamp": "datetime.datetime",
    "date": "datetime.date",
    "time": "datetime.time",
    "timetz": "datetime.time",
    "interval": "datetime.timedelta",
    "boolean": "bool",
    "bool": "bool",
    "jsonb": "dict[str, Any]",
    "json": "dict[str, Any]",
    "bigint": "int",
    "int8": "int",
    "integer": "int",
    "int4": "int",
    "smallint": "int",
    "int2": "int",
    "serial": "int",
    "bigserial": "int",
    "real": "float",
    "float4": "float",
    "double precision": "float",
    "float8": "float",
    "numeric": "float",
    "decimal": "float",
    "money": "float",
    "uuid": "str",
    "bytea": "bytes",
    "inet": "str",
    "cidr": "str",
    "macaddr": "str",
    "point": "str",
    "line": "str",
    "lseg": "str",
    "box": "str",
    "path": "str",
    "polygon": "str",
    "circle": "str",
}


async def get_enum_foreign_keys() -> dict[tuple[str, str], str]:
    """Query PostgreSQL catalog to get foreign key relationships to enum tables.
    
    Returns a mapping of (table_name, column_name) -> enum_type_name
    """
    fk_mapping = {}

    async with connect_db_admin() as conn:
        # Query foreign key relationships where the referenced table ends with '_enum'
        query = """
        SELECT 
            tc.table_name,
            kcu.column_name,
            ccu.table_name AS foreign_table_name
        FROM 
            information_schema.table_constraints AS tc 
            JOIN information_schema.key_column_usage AS kcu
                ON tc.constraint_name = kcu.constraint_name
                AND tc.table_schema = kcu.table_schema
            JOIN information_schema.constraint_column_usage AS ccu
                ON ccu.constraint_name = tc.constraint_name
                AND ccu.table_schema = tc.table_schema
        WHERE 
            tc.constraint_type = 'FOREIGN KEY' 
            AND tc.table_schema = 'public'
            AND ccu.table_name LIKE '%_enum'
        ORDER BY tc.table_name, kcu.column_name
        """

        result = await conn.execute(sqlalchemy.text(query))
        for row in result:
            table_name, column_name, foreign_table_name = row
            # Generate enum type name from foreign table name
            base_name = foreign_table_name[:-5]  # Remove "_enum"
            enum_type = _to_pascal_case(base_name) + "Enum"
            fk_mapping[table_name, column_name] = enum_type

    return fk_mapping


def map_postgres_type_to_python(column: Column, enum_fk_mapping: dict[tuple[str, str], str] | None = None) -> str:
    """Convert PostgreSQL column type to Python type annotation."""
    # Get the base type name
    type_name = column.type.name.lower()

    # Check if this column has a foreign key to an enum table
    if enum_fk_mapping and column.table:
        table_name = column.table.name
        fk_key = (table_name, column.name)
        if fk_key in enum_fk_mapping:
            enum_type = enum_fk_mapping[fk_key]
            python_type = f"enums.{enum_type}"
            if not column.not_null:
                python_type = f"{python_type} | None"
            return python_type

    # Handle array types
    if column.is_array or column.array_dims > 0:
        base_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")
        python_type = f"list[{base_type}]"
    else:
        python_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")

    # Handle nullable types
    if not column.not_null:
        python_type = f"{python_type} | None"

    return python_type


def deserialize_request() -> GenerateRequest:
    """Read and deserialize GenerateRequest from stdin."""
    data = sys.stdin.buffer.read()
    return GenerateRequest().parse(data)


def serialize_response(response: GenerateResponse) -> None:
    """Serialize and write GenerateResponse to stdout."""
    data = bytes(response)
    sys.stdout.buffer.write(data)


async def generate_models(catalog: Catalog) -> str:
    """Generate Python dataclass models from database catalog."""
    # First, build a mapping of enum tables to their type names
    enum_tables = {}
    for schema in catalog.schemas:
        if schema.name != "public":
            continue
        for table in schema.tables:
            if table.rel.name.endswith("_enum"):
                base_name = table.rel.name[:-5]  # Remove "_enum"
                type_name = _to_pascal_case(base_name) + "Enum"
                enum_tables[table.rel.name] = type_name

    # Get foreign key mappings for enum tables
    enum_fk_mapping = await get_enum_foreign_keys() if enum_tables else None

    # Prepare template data
    tables = []
    for schema in catalog.schemas:
        # Filter out non-public schema tables
        if schema.name != "public":
            continue

        for table in schema.tables:
            # Skip enum tables - they are handled separately
            if table.rel.name.endswith("_enum"):
                continue

            # De-pluralize table name for class name
            singular_name = _depluralize_table_name(table.rel.name)
            table_data = {
                "class_name": _to_pascal_case(singular_name),
                "columns": [{"name": column.name, "python_type": map_postgres_type_to_python(column, enum_fk_mapping)} for column in table.columns],
            }
            tables.append(table_data)

    # Render template
    template = jinja2.Template(MODELS_TEMPLATE)
    return template.render(tables=tables, has_enums=bool(enum_tables))


async def generate_enums(catalog: Catalog) -> str:
    """Generate Python enum types from _enum suffixed tables."""
    # Find all enum tables
    enum_tables = []
    for schema in catalog.schemas:
        # Only process public schema tables
        if schema.name != "public":
            continue

        for table in schema.tables:
            if table.rel.name.endswith("_enum"):
                enum_tables.append(table.rel.name)

    if not enum_tables:
        return ""

    # Connect to database and query enum values
    enums = []

    async with connect_db_admin() as conn:
        for table_name in enum_tables:
            # Query the enum values from the table
            # Assuming enum tables have a 'value' column - this might need adjustment
            result = await conn.execute(sqlalchemy.text(f"SELECT value FROM {table_name} ORDER BY value"))
            values = [row[0] for row in result]

            if values:
                # Generate type name from table name (remove _enum suffix)
                base_name = table_name[:-5]  # Remove "_enum"
                type_name = _to_pascal_case(base_name) + "Enum"
                values_name = base_name.upper() + "_ENUM_VALUES"

                enum_data = {
                    "table_name": table_name,
                    "type_name": type_name,
                    "values_name": values_name,
                    "literal_values": ", ".join(f'"{value}"' for value in values),
                    "values_list": str(values),
                }
                enums.append(enum_data)

    # Render template
    template = jinja2.Template(ENUMS_TEMPLATE)
    return template.render(enums=enums)


def _to_pascal_case(snake_str: str) -> str:
    """Convert snake_case to PascalCase."""
    return "".join(word.capitalize() for word in snake_str.split("_"))


def _depluralize_table_name(table_name: str) -> str:
    """Convert plural table names to singular model names."""
    # Simple rules for common English pluralization patterns
    if table_name.endswith("ies"):
        return table_name[:-3] + "y"  # companies -> company
    elif table_name.endswith("ves"):
        return table_name[:-3] + "f"  # wolves -> wolf
    elif table_name.endswith(("ses", "ches", "xes")):
        return table_name[:-2]  # boxes -> box, watches -> watch
    elif table_name.endswith("s") and not table_name.endswith("ss"):
        return table_name[:-1]  # users -> user, but pass -> pass
    else:
        return table_name  # already singular or unknown pattern


def generate_queries(queries: list[Query]) -> str:
    """Generate Python query functions from SQLc queries."""
    # Prepare template data
    query_data = []
    for query in queries:
        query_info = {
            "name": query.name,
            "constant_name": query.name.upper(),
            "text": query.text,
            "cmd": query.cmd,
            "params_signature": _generate_function_parameters(query.params),
            "return_type": _generate_return_type(query),
            "param_dict": _generate_param_dict(query.params),
            "model_name": _infer_model_name(query) if query.columns else None,
            "columns": [{"name": col.name} for col in query.columns] if query.columns else None,
            "error_params": _generate_error_params(query),
        }
        query_data.append(query_info)

    # Render template
    template = jinja2.Template(QUERIES_TEMPLATE)
    return template.render(queries=query_data)


def _generate_function_parameters(params: list[Parameter]) -> str:
    """Generate function parameters from query parameters."""
    if not params:
        return ""

    param_strs = []
    for param in params:
        param_name = param.column.name if param.column.name else f"p{param.number}"
        param_type = map_postgres_type_to_python(param.column)
        param_strs.append(f"{param_name}: {param_type}")

    return ", *, " + ", ".join(param_strs)


def _generate_param_dict(params: list[Parameter]) -> str:
    """Generate parameter dictionary for SQLAlchemy execution."""
    if not params:
        return "{}"

    param_dict_items = []
    for param in params:
        param_name = param.column.name if param.column.name else f"p{param.number}"
        param_dict_items.append(f'"p{param.number}": {param_name}')

    return "{" + ", ".join(param_dict_items) + "}"


def _generate_error_params(query: Query) -> str:
    """Generate NotFoundError parameters for :one queries."""
    # Try to infer resource name from query or model
    if query.columns:
        resource = _infer_model_name(query).lower()
    else:
        resource = query.name.replace("_", " ")

    # If we have parameters, use the first one as the key
    if query.params:
        first_param = query.params[0]
        key_name = first_param.column.name if first_param.column.name else f"p{first_param.number}"
        key_value = key_name  # The variable name
        return f'resource="{resource}", key_name="{key_name}", key_value=str({key_value})'
    else:
        # No parameters, use a generic approach
        return f'resource="{resource}", key_name="query", key_value="{query.name}"'


def _generate_return_type(query: Query) -> str:
    """Generate return type annotation for query function."""
    if query.cmd == ":exec":
        return "None"
    elif query.cmd == ":one":
        if query.columns:
            model_name = _infer_model_name(query)
            return f"models.{model_name}"
        else:
            return "Any"
    elif query.cmd == ":many":
        if query.columns:
            model_name = _infer_model_name(query)
            return f"AsyncIterator[models.{model_name}]"
        else:
            return "AsyncIterator[Any]"
    else:
        return "Any"


def _infer_model_name(query: Query) -> str:
    """Infer model name from query columns or table."""
    # Try to get from insert_into_table first
    if query.insert_into_table and query.insert_into_table.name:
        singular_name = _depluralize_table_name(query.insert_into_table.name)
        return _to_pascal_case(singular_name)

    # Try to infer from first column's table
    for column in query.columns:
        if column.table and column.table.name:
            singular_name = _depluralize_table_name(column.table.name)
            return _to_pascal_case(singular_name)

    # Fallback: use query name
    return _to_pascal_case(query.name.replace("_", ""))


@click.command()
@click.argument("service_method", required=False)
def main(service_method: str | None = None) -> None:
    """SQLc Python code generation plugin main entry point."""
    assert service_method == "/plugin.CodegenService/Generate", f"Unexpected service method: {service_method}"
    asyncio.run(_async_main())


async def _async_main() -> None:
    """Async main function to handle database connections."""
    # Deserialize request from stdin
    request = deserialize_request()

    # Generate models, enums, and queries
    models_content = await generate_models(request.catalog)
    enums_content = await generate_enums(request.catalog)
    queries_content = generate_queries(request.queries)

    # Create response with generated files
    response = GenerateResponse()

    # Add models file
    models_file = File(name="models.py", contents=models_content.encode("utf-8"))
    response.files.append(models_file)

    # Add enums file if we have enum content
    if enums_content.strip():
        enums_file = File(name="enums.py", contents=enums_content.encode("utf-8"))
        response.files.append(enums_file)

    # Add queries file
    queries_file = File(name="queries.py", contents=queries_content.encode("utf-8"))
    response.files.append(queries_file)

    # Serialize response to stdout
    serialize_response(response)


if __name__ == "__main__":
    main()
