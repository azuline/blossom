#!/usr/bin/env python3
"""SQLc Python code generation plugin."""

import sys
from typing import Any

import click

from tools.sqlc_gen_python.plugin import GenerateRequest, GenerateResponse, File, Catalog, Query, Column


# PostgreSQL to Python type mapping
POSTGRES_TO_PYTHON_TYPES = {
    "text": "str",
    "varchar": "str", 
    "char": "str",
    "bpchar": "str",
    "timestamptz": "datetime.datetime",
    "timestamp": "datetime.datetime",
    "date": "datetime.date",
    "time": "datetime.time",
    "timetz": "datetime.time",
    "interval": "datetime.timedelta",
    "boolean": "bool",
    "bool": "bool",
    "jsonb": "Any",
    "json": "Any",
    "bigint": "int",
    "int8": "int",
    "integer": "int",
    "int4": "int",
    "smallint": "int",
    "int2": "int",
    "serial": "int",
    "bigserial": "int",
    "real": "float",
    "float4": "float",
    "double precision": "float",
    "float8": "float",
    "numeric": "float",
    "decimal": "float",
    "money": "float",
    "uuid": "str",
    "bytea": "bytes",
    "inet": "str",
    "cidr": "str",
    "macaddr": "str",
    "point": "str",
    "line": "str",
    "lseg": "str",
    "box": "str",
    "path": "str",
    "polygon": "str",
    "circle": "str",
}


def map_postgres_type_to_python(column: Column) -> str:
    """Convert PostgreSQL column type to Python type annotation."""
    # Get the base type name
    type_name = column.type.name.lower()
    
    # Handle array types
    if column.is_array or column.array_dims > 0:
        base_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")
        python_type = f"list[{base_type}]"
    else:
        python_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")
    
    # Handle nullable types
    if not column.not_null:
        python_type = f"{python_type} | None"
    
    return python_type


def deserialize_request() -> GenerateRequest:
    """Read and deserialize GenerateRequest from stdin."""
    data = sys.stdin.buffer.read()
    return GenerateRequest().parse(data)


def serialize_response(response: GenerateResponse) -> None:
    """Serialize and write GenerateResponse to stdout."""
    data = bytes(response)
    sys.stdout.buffer.write(data)


def generate_models(catalog: Catalog) -> str:
    """Generate Python dataclass models from database catalog."""
    lines = [
        "# Code generated by sqlc. DO NOT EDIT.",
        "import dataclasses",
        "import datetime",
        "from typing import Any",
        "",
    ]
    
    # Generate dataclass for each table
    for schema in catalog.schemas:
        for table in schema.tables:
            # Generate the dataclass
            class_name = _to_pascal_case(table.rel.name)
            lines.append(f"@dataclasses.dataclass(slots=True)")
            lines.append(f"class {class_name}:")
            
            # Generate fields for each column
            for column in table.columns:
                python_type = map_postgres_type_to_python(column)
                lines.append(f"    {column.name}: {python_type}")
            
            lines.append("")  # Empty line after each class
    
    return "\n".join(lines)


def _to_pascal_case(snake_str: str) -> str:
    """Convert snake_case to PascalCase."""
    return "".join(word.capitalize() for word in snake_str.split("_"))


def generate_queries(queries: list[Query]) -> str:
    """Generate Python query functions from SQLc queries."""
    # TODO: Implement query generation
    return "# Queries will be generated here"


@click.command()
def main() -> None:
    """SQLc Python code generation plugin main entry point."""
    try:
        # Deserialize request from stdin
        request = deserialize_request()
        
        # Generate models and queries
        models_content = generate_models(request.catalog)
        queries_content = generate_queries(request.queries)
        
        # Create response with generated files
        response = GenerateResponse()
        
        # Add models file
        models_file = File(
            name="models.py",
            contents=models_content.encode('utf-8')
        )
        response.files.append(models_file)
        
        # Add queries file
        queries_file = File(
            name="queries.py", 
            contents=queries_content.encode('utf-8')
        )
        response.files.append(queries_file)
        
        # Serialize response to stdout
        serialize_response(response)
        
    except Exception as e:
        # Write error to stderr and exit with non-zero code
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


if __name__ == "__main__":
    main()