#!/usr/bin/env python3
"""SQLc Python code generation plugin."""

import sys

import click
import jinja2

from tools.sqlc_gen_python.proto import Catalog, Column, File, GenerateRequest, GenerateResponse, Parameter, Query

# Jinja templates for code generation
MODELS_TEMPLATE = """\
# Code generated by sqlc. DO NOT EDIT.
import dataclasses
import datetime
from typing import Any

{% for table in tables -%}
@dataclasses.dataclass(slots=True)
class {{ table.class_name }}:
{%- for column in table.columns %}
    {{ column.name }}: {{ column.python_type }}
{%- endfor %}

{% endfor -%}
"""

QUERIES_TEMPLATE = '''\
# Code generated by sqlc. DO NOT EDIT.
import datetime
from typing import AsyncIterator
import sqlalchemy
from database.conn import DBConn
from database.__codegen__ import models

{% for query in queries -%}
{{ query.constant_name }} = """-- name: {{ query.name }} {{ query.cmd }}
{{ query.text }}
"""

async def {{ query.name }}(conn: DBConn{{ query.params_signature }}) -> {{ query.return_type }}:
{%- if query.cmd == ":exec" %}
    await conn.execute(sqlalchemy.text({{ query.constant_name }}), {{ query.param_dict }})
{%- elif query.cmd == ":one" %}
    row = (await conn.execute(sqlalchemy.text({{ query.constant_name }}), {{ query.param_dict }})).first()
    if row is None:
        return None
{%- if query.columns %}
    return models.{{ query.model_name }}(
{%- for column in query.columns %}
        {{ column.name }}=row[{{ loop.index0 }}],
{%- endfor %}
    )
{%- else %}
    return row
{%- endif %}
{%- elif query.cmd == ":many" %}
    result = await conn.execute(sqlalchemy.text({{ query.constant_name }}), {{ query.param_dict }})
    async for row in result:
{%- if query.columns %}
        yield models.{{ query.model_name }}(
{%- for column in query.columns %}
            {{ column.name }}=row[{{ loop.index0 }}],
{%- endfor %}
        )
{%- else %}
        yield row
{%- endif %}
{%- endif %}

{% endfor -%}
'''


# PostgreSQL to Python type mapping
POSTGRES_TO_PYTHON_TYPES = {
    "text": "str",
    "varchar": "str",
    "char": "str",
    "bpchar": "str",
    "timestamptz": "datetime.datetime",
    "timestamp": "datetime.datetime",
    "date": "datetime.date",
    "time": "datetime.time",
    "timetz": "datetime.time",
    "interval": "datetime.timedelta",
    "boolean": "bool",
    "bool": "bool",
    "jsonb": "Any",
    "json": "Any",
    "bigint": "int",
    "int8": "int",
    "integer": "int",
    "int4": "int",
    "smallint": "int",
    "int2": "int",
    "serial": "int",
    "bigserial": "int",
    "real": "float",
    "float4": "float",
    "double precision": "float",
    "float8": "float",
    "numeric": "float",
    "decimal": "float",
    "money": "float",
    "uuid": "str",
    "bytea": "bytes",
    "inet": "str",
    "cidr": "str",
    "macaddr": "str",
    "point": "str",
    "line": "str",
    "lseg": "str",
    "box": "str",
    "path": "str",
    "polygon": "str",
    "circle": "str",
}


def map_postgres_type_to_python(column: Column) -> str:
    """Convert PostgreSQL column type to Python type annotation."""
    # Get the base type name
    type_name = column.type.name.lower()

    # Handle array types
    if column.is_array or column.array_dims > 0:
        base_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")
        python_type = f"list[{base_type}]"
    else:
        python_type = POSTGRES_TO_PYTHON_TYPES.get(type_name, "Any")

    # Handle nullable types
    if not column.not_null:
        python_type = f"{python_type} | None"

    return python_type


def deserialize_request() -> GenerateRequest:
    """Read and deserialize GenerateRequest from stdin."""
    data = sys.stdin.buffer.read()
    return GenerateRequest().parse(data)


def serialize_response(response: GenerateResponse) -> None:
    """Serialize and write GenerateResponse to stdout."""
    data = bytes(response)
    sys.stdout.buffer.write(data)


def generate_models(catalog: Catalog) -> str:
    """Generate Python dataclass models from database catalog."""
    # Prepare template data
    tables = []
    for schema in catalog.schemas:
        for table in schema.tables:
            table_data = {
                "class_name": _to_pascal_case(table.rel.name),
                "columns": [{"name": column.name, "python_type": map_postgres_type_to_python(column)} for column in table.columns],
            }
            tables.append(table_data)

    # Render template
    template = jinja2.Template(MODELS_TEMPLATE)
    return template.render(tables=tables)


def _to_pascal_case(snake_str: str) -> str:
    """Convert snake_case to PascalCase."""
    return "".join(word.capitalize() for word in snake_str.split("_"))


def generate_queries(queries: list[Query]) -> str:
    """Generate Python query functions from SQLc queries."""
    # Prepare template data
    query_data = []
    for query in queries:
        query_info = {
            "name": query.name,
            "constant_name": query.name.upper(),
            "text": query.text,
            "cmd": query.cmd,
            "params_signature": _generate_function_parameters(query.params),
            "return_type": _generate_return_type(query),
            "param_dict": _generate_param_dict(query.params),
            "model_name": _infer_model_name(query) if query.columns else None,
            "columns": [{"name": col.name} for col in query.columns] if query.columns else None,
        }
        query_data.append(query_info)

    # Render template
    template = jinja2.Template(QUERIES_TEMPLATE)
    return template.render(queries=query_data)


def _generate_function_parameters(params: list[Parameter]) -> str:
    """Generate function parameters from query parameters."""
    if not params:
        return ""

    param_strs = []
    for param in params:
        param_name = param.column.name if param.column.name else f"p{param.number}"
        param_type = map_postgres_type_to_python(param.column)
        param_strs.append(f"{param_name}: {param_type}")

    return ", *, " + ", ".join(param_strs)


def _generate_param_dict(params: list[Parameter]) -> str:
    """Generate parameter dictionary for SQLAlchemy execution."""
    if not params:
        return "{}"

    param_dict_items = []
    for param in params:
        param_name = param.column.name if param.column.name else f"p{param.number}"
        param_dict_items.append(f'"p{param.number}": {param_name}')

    return "{" + ", ".join(param_dict_items) + "}"


def _generate_return_type(query: Query) -> str:
    """Generate return type annotation for query function."""
    if query.cmd == ":exec":
        return "None"
    elif query.cmd == ":one":
        if query.columns:
            model_name = _infer_model_name(query)
            return f"models.{model_name} | None"
        else:
            return "Any | None"
    elif query.cmd == ":many":
        if query.columns:
            model_name = _infer_model_name(query)
            return f"AsyncIterator[models.{model_name}]"
        else:
            return "AsyncIterator[Any]"
    else:
        return "Any"


def _infer_model_name(query: Query) -> str:
    """Infer model name from query columns or table."""
    # Try to get from insert_into_table first
    if query.insert_into_table and query.insert_into_table.name:
        return _to_pascal_case(query.insert_into_table.name)

    # Try to infer from first column's table
    for column in query.columns:
        if column.table and column.table.name:
            return _to_pascal_case(column.table.name)

    # Fallback: use query name
    return _to_pascal_case(query.name.replace("_", ""))


@click.command()
@click.argument("service_method", required=False)
def main(service_method: str | None = None) -> None:
    """SQLc Python code generation plugin main entry point."""
    # Assert that we're being called with the expected gRPC service method
    if service_method is not None:
        assert service_method == "/plugin.CodegenService/Generate", f"Unexpected service method: {service_method}"
    try:
        # Deserialize request from stdin
        request = deserialize_request()

        # Generate models and queries
        models_content = generate_models(request.catalog)
        queries_content = generate_queries(request.queries)

        # Create response with generated files
        response = GenerateResponse()

        # Add models file
        models_file = File(name="models.py", contents=models_content.encode("utf-8"))
        response.files.append(models_file)

        # Add queries file
        queries_file = File(name="queries.py", contents=queries_content.encode("utf-8"))
        response.files.append(queries_file)

        # Serialize response to stdout
        serialize_response(response)

    except Exception as e:
        # Write error to stderr and exit with non-zero code
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
