"""Run SQLc codegen using a test database."""

import asyncio
import re
import shutil
import subprocess
import tempfile
from pathlib import Path

import yaml
from sqlalchemy import text

from database.conn import connect_db_admin
from database.testdb import TestDB
from foundation.env import ENV
from foundation.observability.logs import get_logger
from foundation.stdlib.paths import PYTHON_ROOT

logger = get_logger()


async def main():
    """Run SQLc codegen."""
    # Clean up all existing __codegen_db__ directories
    logger.info("cleaning up existing __codegen_db__ directories")
    for codegen_dir in PYTHON_ROOT.rglob("__codegen_db__"):
        if codegen_dir.is_dir():
            shutil.rmtree(codegen_dir)

    testdb = TestDB()
    out_dir = PYTHON_ROOT / "database/__codegen_db__"

    db_name = await testdb.create_db()
    original_database_uri = ENV.database_uri
    ENV.database_uri = testdb.database_uri(db_name)
    try:
        logger.info("using test database for codegen", db_name=db_name)

        logger.info("generating schema.sql")
        subprocess.run(["pgmigrate", "dump", "-d", ENV.database_uri, "--out", str(PYTHON_ROOT / "database/schema.sql")], check=True)
        logger.info("schema.sql generated successfully")

        # Generate sqlc :: models.py and queries.py
        with tempfile.NamedTemporaryFile(prefix=".sqlc.config", suffix=".yaml", dir=".") as tmp_config:
            with Path("sqlc.yaml").open("r") as f:
                config = yaml.safe_load(f)
            config["sql"][0]["database"]["uri"] = ENV.database_uri
            with Path(tmp_config.name).open("w") as tmp:
                yaml.dump(config, tmp, default_flow_style=False)

            logger.info("validating database queries")
            subprocess.run(["sqlc", "vet", "-f", tmp_config.name], check=True)
            logger.info("generating python bindings")
            if out_dir.exists():
                shutil.rmtree(out_dir)
            out_dir.mkdir()
            (out_dir / "__init__.py").touch()
            subprocess.run(["sqlc", "generate", "-f", tmp_config.name], check=True)
            logger.info("codegen completed successfully")

        # Generate table map :: tables.py
        table_map_filepath = out_dir / "tables.py"
        table_map_filepath.unlink(missing_ok=True)
        defaults: list[tuple[str, str]] = []
        async with connect_db_admin() as conn:
            cursor = await conn.execute(
                text("""
                    SELECT c.table_name, c.column_default
                    FROM information_schema.columns c
                    JOIN information_schema.tables t
                        ON c.table_name = t.table_name
                    WHERE c.column_name = 'id'
                    AND t.table_schema = 'public'
                    AND t.table_type = 'BASE TABLE'
                    AND t.table_name NOT LIKE '%yoyo%'
                    AND c.column_default LIKE  'generate_id(%'
                """)
            )
            pattern = re.compile(r"generate_id\('([^']+)'::text\)")
            for row in cursor:
                table = row[0]
                m = pattern.match(row[1])
                assert m is not None
                default = m[1]
                defaults.append((table, default))
        with table_map_filepath.open("w") as fp:
            fp.write(f"""\
# Code generated by python/tools/codegen_db. DO NOT EDIT.

from typing import Literal

type DatabaseTablePrefixEnum = Literal[{", ".join(f'"{d}"' for _, d in defaults)}]

DATABASE_TABLE_PREFIX_MAP: dict[DatabaseTablePrefixEnum, str] = {{
    {",\n    ".join(f'"{default}": "{table}"' for table, default in defaults)},
}}
""")
    finally:
        ENV.database_uri = original_database_uri
        await testdb.drop_db(db_name)


if __name__ == "__main__":
    asyncio.run(main())
