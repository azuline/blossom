from __future__ import annotations

import dataclasses
import os
import re
import subprocess
from pathlib import Path
from typing import Any, Literal, TypeVar, get_args, get_origin, get_type_hints

from jinja2 import BaseLoader, Environment
from pydantic import BaseModel

from foundation.errors import BaseError
from foundation.logs import get_logger
from foundation.paths import MONOREPO_ROOT
from foundation.rpc import RPCError, RPCRouter
from panopticon.app import create_router_panopticon
from product.app import create_router_product

logger = get_logger()

# nosemgrep
TEMPLATE = """\
/* Code generated by python/tools/codegen-rpc. DO NOT EDIT. */

import type { Dayjs } from "dayjs";

/**
 * All Errors
 */

export type RPCErrors = {
  {% for errname, err in catalog.errors.items() %}
  {% if err.data %}
  {{ errname }}: {{ err.data }};
  {% else %}
  {{ errname }}: null;
  {% endif %}
  {% endfor %}
  // These are errors that the frontend RPC executor can raise.
  NetworkError: null;
  InternalServerError: null;
  RPCNotFoundError: null;
  ClientJSONDecodeError: null;
  UncaughtRPCError: null;
};

/**
 * System Errors
 */

export type RPCSystemErrors =
  | "NetworkError"
  | "InternalServerError"
  | "RPCNotFoundError"
  | "ClientJSONDecodeError"
  | "UncaughtRPCError"
  {% for errname in catalog.global_error_names %}
  | "{{ errname }}"
  {% endfor %}
  ;

/**
 * Nested & Common
 */

{% for name, value in catalog.global_types.items() %}
export type {{ name }} = {{ value }};

{% endfor %}
/**
 * RPC I/O
 */

export type RPCs = {
  {% for rpcname, rpc in catalog.rpcs.items() %}
  {{ rpcname }}: {
    in: {{ rpc.in_ }};
    out: {{ rpc.out }};
    {% if rpc.error_names %}
    errors:
      {% for errname in rpc.error_names %}
      | "{{ errname }}"
      {% endfor %}
      ;
    {% else %}
    errors: never;
    {% endif %}
  },
  {% endfor %}
};

/**
 * RPC Methods
 */

export const RPCMethods: Record<keyof RPCs, "GET" | "POST"> = {
  {% for rpcname, rpc in catalog.rpcs.items() %}
  {{ rpcname }}: "{{ rpc.method }}",
  {% endfor %}
};
"""

PRODUCT_GOD_MODE_TEMPLATE = """\
/**
 * These routes are located in the panopticon backend and are not accessible to customers. They
 * should only be called in god mode for information and actions that we do not want to ever make
 * publicly accessible.
 */

export const GodModeRPCs: (keyof RPCs)[] = [
  {% for rpc in catalog.god_mode_rpcs %}
  "{{ rpc }}",
  {% endfor %}
];
"""


def codegen_rpc_models(router: RPCRouter, dst: Path) -> None:
    catalog = create_codegen_schema(router)

    env = Environment(loader=BaseLoader(), trim_blocks=True)
    tmpl = env.from_string(TEMPLATE)  # nosemgrep
    code = tmpl.render(catalog=catalog)

    if catalog.god_mode_rpcs:
        tmpl = env.from_string(PRODUCT_GOD_MODE_TEMPLATE)  # nosemgrep
        code += "\n" + tmpl.render(catalog=catalog)

    dst.parent.mkdir(parents=True, exist_ok=True)
    with dst.open("w") as fptr:
        fptr.write(code)
    os.chdir(MONOREPO_ROOT / "typescript")


@dataclasses.dataclass(slots=True)
class RPCSchema:
    in_: str | None
    out: str | None
    method: Literal["GET", "POST"]
    error_names: list[str]


@dataclasses.dataclass(slots=True)
class ErrorSchema:
    data: str | None


@dataclasses.dataclass(slots=True)
class CodegenSchema:
    errors: dict[str, ErrorSchema]
    rpcs: dict[str, RPCSchema]
    global_error_names: list[str]
    global_types: dict[str, str]
    # Special tenant routes located in admin..
    god_mode_rpcs: list[str]


@dataclasses.dataclass(slots=True)
class _GenerationCache:
    # A cache of `module.type -> typename`.
    type_cache: dict[str, str] = dataclasses.field(default_factory=dict)
    # A map of used type names to detect name collisions.
    type_names: dict[str, str] = dataclasses.field(default_factory=dict)


class UnsupportedTypeError(BaseError):
    pass


class NameCollisionError(BaseError):
    pass


def create_codegen_schema(router: RPCRouter) -> CodegenSchema:
    """
    Convert the RPC schema with its dataclass type annotations into a string form that can be used
    to construct a TypeScript equivalent version.
    """
    schema = CodegenSchema(errors={}, rpcs={}, god_mode_rpcs=[], global_error_names=[], global_types={})
    cache = _GenerationCache()

    def add_error_to_schema(e: type[RPCError]) -> None:
        """Raises an error if the error has the same name but a duplicate schema."""
        name = e.__name__
        esch = ErrorSchema(data=dataclass_to_str(e, schema, cache))
        if name in schema.errors and schema.errors[name] != esch:
            raise NameCollisionError(f"the error name {name} has multiple definitions with different schemas")
        schema.errors[name] = esch

    for e in router.global_errors:
        logger.debug("Adding global error to schema", error=e, name=e.__name__)
        add_error_to_schema(e)
        schema.global_error_names.append(e.__name__)

    for r in router.routes:
        for e in r.errors:
            logger.debug("Adding route-scoped error to schema", route=r.name, error=e, name=e.__name__)
            add_error_to_schema(e)
        logger.debug("Adding route to schema", route=r.name, in_=r.in_, out=r.out, method=r.method)
        schema.rpcs[r.name] = RPCSchema(
            in_=dataclass_to_str(r.in_, schema, cache, optional=True) if r.in_.__name__ != "NoneType" else "null",
            out=dataclass_to_str(r.out, schema, cache) if r.out.__name__ != "NoneType" else "null",
            method=r.method,
            error_names=[e.__name__ for e in r.errors],
        )
        if "god_mode" in router.route_flags[r]:
            schema.god_mode_rpcs.append(r.name)

    return schema


def dataclass_to_str(d: type[Any], out: CodegenSchema, cache: _GenerationCache, optional: bool = False) -> str:
    schema = {}
    type_hints = get_type_hints(d)
    for f in dataclasses.fields(d):
        schema[f.name] = type_to_str(type_hints[f.name], out, cache)
    if not schema:
        return "null"
    val = "{\n"
    for k, v in schema.items():
        if optional and re.search(r"\bundefined\b", v) is not None:
            val += f'"{k}"?: {v};\n'
        else:
            val += f'"{k}": {v};\n'
    val += "}"
    return val


def type_to_str(t: Any, out: CodegenSchema, cache: _GenerationCache) -> str:
    # Nested types are split out into their own types. We compute and store their names here.
    if isinstance(t, type) and (dataclasses.is_dataclass(t) or issubclass(t, BaseModel)):
        t_cachekey = f"{t.__module__}:{t.__name__}"
        # Case 1: Already computed; reuse cached type name.
        if prev := cache.type_cache.get(t_cachekey):
            return prev
        # Case 2: Name collision with another type, error.
        if other := cache.type_names.get(t.__name__):
            raise NameCollisionError(f"the name of {t_cachekey} collides with {other}, please make them distinct")
        # Case 3: New type new name new hair new jeans.
        cache.type_cache[t_cachekey] = t.__name__
        cache.type_names[t.__name__] = t_cachekey
        # Only compute the recursive dataclass after setting the cache values to solve for mutual
        # recursion. If we don't do this, it will infinitely recurse.
        out.global_types[t.__name__] = dataclass_to_str(t, out, cache) if dataclasses.is_dataclass(t) else pydantic_to_str(t, out)
        return t.__name__

    t_name = getattr(t, "__name__", None)
    t_qualname = f"{t.__module__}.{t_name}" if hasattr(t, "__module__") and t_name else None

    if t_name == "str":
        return "string"
    if t_name == "int" or t_name == "float":
        return "number"
    if t_name == "bool":
        return "boolean"
    if t_qualname in ("datetime.datetime", "datetime.date"):
        return "Dayjs"
    if t_name == "NoneType":
        return "null"
    if t_name == "Unset":
        return "undefined"
    if t_name == "Any":
        return "unknown"

    origin = get_origin(t)
    args = get_args(t)

    origin_name = getattr(origin, "__name__", None)

    if origin_name == "list":
        return "(" + type_to_str(args[0], out, cache) + ")[]"
    if origin_name == "tuple":
        return "[" + ", ".join([type_to_str(a, out, cache) for a in args]) + "]"
    if origin_name == "dict":
        return "Record<" + type_to_str(args[0], out, cache) + ", " + type_to_str(args[1], out, cache) + ">"
    if origin_name == "Literal":
        values = []
        for a in args:
            if isinstance(a, int):
                values.append(str(a))
            else:
                assert isinstance(a, str)
                values.append(f'"{a}"')
        return " | ".join(values)
    if origin_name == "UnionType" or origin_name == "Union":
        return " | ".join([type_to_str(a, out, cache) for a in args])

    if isinstance(t, TypeVar):
        return "unknown"

    raise UnsupportedTypeError(
        f"""\
Failed to convert type {t=} {t_name=} {t_qualname=} {origin=} {origin_name=} {args=}.

    If this is not an unimplemented standard type, it should probably be a dataclass.
    If this type should not be converted, add it to script/codegen/rpc.py:ANY_TYPES.
"""
    )


def codegen_product() -> None:
    dst = MONOREPO_ROOT / "typescript/product/src/z-rpc/types.ts"
    codegen_rpc_models(create_router_product(), dst)
    subprocess.run(["biome", "format", "--write", str(dst)], check=False)
    # TODO: god mode


def codegen_panopticon() -> None:
    dst = MONOREPO_ROOT / "typescript/panopticon/src/z-rpc/types.ts"
    codegen_rpc_models(create_router_panopticon(), dst)
    subprocess.run(["biome", "format", "--write", str(dst)], check=False)


if __name__ == "__main__":
    codegen_product()
    codegen_panopticon()
