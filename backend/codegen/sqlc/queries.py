# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.20.0
# source: queries.sql
import datetime
from typing import Any, AsyncIterator, Optional

import psycopg

from codegen.sqlc import models


AUTHN_CREATE_SESSION = """-- name: authn_create_session \\:one
INSERT INTO sessions (user_id, tenant_id)
VALUES (%s, %s)
RETURNING id, external_id, created_at, updated_at, user_id, tenant_id, last_seen_at, expired_at
"""


AUTHN_EXPIRE_SESSION = """-- name: authn_expire_session \\:exec
UPDATE sessions
SET expired_at = NOW() 
WHERE external_id = %s
"""


AUTHN_FETCH_LINKED_TENANT = """-- name: authn_fetch_linked_tenant \\:one
SELECT t.id, t.external_id, t.created_at, t.updated_at, t.name, t.inbound_source
FROM tenants t
JOIN tenants_users tu ON tu.tenant_id = t.id
WHERE tu.user_id = %s AND t.external_id = %s
"""


AUTHN_FETCH_MOST_RECENTLY_ACCESSED_TENANT = """-- name: authn_fetch_most_recently_accessed_tenant \\:one
SELECT t.id, t.external_id, t.created_at, t.updated_at, t.name, t.inbound_source
FROM tenants t
JOIN tenants_users tu ON tu.tenant_id = t.id
LEFT JOIN sessions s ON s.tenant_id = t.id AND s.user_id = tu.user_id
WHERE tu.user_id = %s
ORDER BY s.last_seen_at DESC NULLS LAST, t.id ASC
LIMIT 1
"""


AUTHN_FETCH_SESSION_BY_USER = """-- name: authn_fetch_session_by_user \\:one
SELECT id, external_id, created_at, updated_at, user_id, tenant_id, last_seen_at, expired_at
FROM sessions
WHERE user_id = %s
ORDER BY last_seen_at DESC
LIMIT 1
"""


AUTHN_FETCH_USER_EMAIL = """-- name: authn_fetch_user_email \\:one
SELECT id, external_id, created_at, updated_at, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE email = %s
"""


RPC_FETCH_UNEXPIRED_SESSION = """-- name: rpc_fetch_unexpired_session \\:one
SELECT id, external_id, created_at, updated_at, user_id, tenant_id, last_seen_at, expired_at
FROM sessions
WHERE external_id = %s
AND expired_at IS NULL
AND last_seen_at > NOW() - '14 days'::INTERVAL
"""


TENANT_ADD_USER = """-- name: tenant_add_user \\:one
INSERT INTO tenants_users (tenant_id, user_id)
VALUES (%s, %s)
RETURNING id, external_id, created_at, updated_at, user_id, tenant_id, removed_at, removed_by_user
"""


TENANT_CREATE = """-- name: tenant_create \\:one
INSERT INTO tenants (name, inbound_source)
VALUES (%s, %s)
RETURNING id, external_id, created_at, updated_at, name, inbound_source
"""


TENANT_FETCH = """-- name: tenant_fetch \\:one
SELECT id, external_id, created_at, updated_at, name, inbound_source
FROM tenants
WHERE id = %s
"""


TENANT_FETCH_ALL = """-- name: tenant_fetch_all \\:many
SELECT t.id, t.external_id, t.created_at, t.updated_at, t.name, t.inbound_source
FROM tenants t
JOIN tenants_users tu ON tu.tenant_id = t.id
WHERE tu.user_id = %s
"""


TENANT_FETCH_EXT = """-- name: tenant_fetch_ext \\:one
SELECT id, external_id, created_at, updated_at, name, inbound_source
FROM tenants
WHERE external_id = %s
"""


TEST_SESSION_CREATE = """-- name: test_session_create \\:one
INSERT INTO sessions (user_id, tenant_id, expired_at, last_seen_at)
VALUES (%s, %s, %s, %s)
RETURNING id, external_id, created_at, updated_at, user_id, tenant_id, last_seen_at, expired_at
"""


TEST_TENANT_CREATE = """-- name: test_tenant_create \\:one
INSERT INTO tenants (name, inbound_source)
VALUES (%s, %s)
RETURNING id, external_id, created_at, updated_at, name, inbound_source
"""


TEST_TENANT_USER_CREATE = """-- name: test_tenant_user_create \\:one
INSERT INTO tenants_users (user_id, tenant_id)
VALUES (%s, %s)
RETURNING id, external_id, created_at, updated_at, user_id, tenant_id, removed_at, removed_by_user
"""


TEST_USER_CREATE = """-- name: test_user_create \\:one
INSERT INTO users (name, email, password_hash, signup_step)
VALUES (%s, %s, %s, 'complete')
RETURNING id, external_id, created_at, updated_at, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""


TEST_USER_CREATE_DISABLED = """-- name: test_user_create_disabled \\:one
INSERT INTO users (name, email, password_hash, signup_step, is_enabled)
VALUES (%s, %s, %s, 'complete', false)
RETURNING id, external_id, created_at, updated_at, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""


TEST_USER_CREATE_NOT_SIGNED_UP = """-- name: test_user_create_not_signed_up \\:one
INSERT INTO users (name, email)
VALUES (%s, %s)
RETURNING id, external_id, created_at, updated_at, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""


USER_CREATE = """-- name: user_create \\:one
INSERT INTO users (name, email, password_hash, signup_step)
VALUES (%s, %s, %s, %s)
RETURNING id, external_id, created_at, updated_at, name, email, password_hash, signup_step, is_enabled, last_visited_at
"""


USER_FETCH = """-- name: user_fetch \\:one
SELECT id, external_id, created_at, updated_at, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE id = %s
"""


USER_FETCH_EXT = """-- name: user_fetch_ext \\:one
SELECT id, external_id, created_at, updated_at, name, email, password_hash, signup_step, is_enabled, last_visited_at
FROM users
WHERE external_id = %s
"""


VAULT_CREATE_SECRET = """-- name: vault_create_secret \\:one
INSERT INTO vaulted_secrets (tenant_id, ciphertext, nonce)
VALUES (%s, %s, %s)
RETURNING id, external_id, created_at, updated_at, tenant_id, ciphertext, nonce
"""


VAULT_DELETE_SECRET = """-- name: vault_delete_secret \\:exec
DELETE
FROM vaulted_secrets
WHERE id = %s
"""


VAULT_FETCH_SECRET = """-- name: vault_fetch_secret \\:one
SELECT id, external_id, created_at, updated_at, tenant_id, ciphertext, nonce
FROM vaulted_secrets
WHERE id = %s
"""


class AsyncQuerier:
    def __init__(self, conn: psycopg.AsyncConnection[Any]):
        self._conn = conn

    async def authn_create_session(self, *, user_id: int, tenant_id: Optional[int]) -> Optional[models.Session]:
        row = await (await self._conn.execute(AUTHN_CREATE_SESSION, (user_id, tenant_id))).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            user_id=row[4],
            tenant_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def authn_expire_session(self, *, external_id: str) -> None:
        await self._conn.execute(AUTHN_EXPIRE_SESSION, (external_id, ))

    async def authn_fetch_linked_tenant(self, *, user_id: int, external_id: str) -> Optional[models.Tenant]:
        row = await (await self._conn.execute(AUTHN_FETCH_LINKED_TENANT, (user_id, external_id))).fetchone()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def authn_fetch_most_recently_accessed_tenant(self, *, user_id: int) -> Optional[models.Tenant]:
        row = await (await self._conn.execute(AUTHN_FETCH_MOST_RECENTLY_ACCESSED_TENANT, (user_id, ))).fetchone()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def authn_fetch_session_by_user(self, *, user_id: int) -> Optional[models.Session]:
        row = await (await self._conn.execute(AUTHN_FETCH_SESSION_BY_USER, (user_id, ))).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            user_id=row[4],
            tenant_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def authn_fetch_user_email(self, *, email: str) -> Optional[models.User]:
        row = await (await self._conn.execute(AUTHN_FETCH_USER_EMAIL, (email, ))).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def rpc_fetch_unexpired_session(self, *, external_id: str) -> Optional[models.Session]:
        row = await (await self._conn.execute(RPC_FETCH_UNEXPIRED_SESSION, (external_id, ))).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            user_id=row[4],
            tenant_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def tenant_add_user(self, *, tenant_id: int, user_id: int) -> Optional[models.TenantsUser]:
        row = await (await self._conn.execute(TENANT_ADD_USER, (tenant_id, user_id))).fetchone()
        if row is None:
            return None
        return models.TenantsUser(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            user_id=row[4],
            tenant_id=row[5],
            removed_at=row[6],
            removed_by_user=row[7],
        )

    async def tenant_create(self, *, name: str, inbound_source: models.TenantsInboundSource) -> Optional[models.Tenant]:
        row = await (await self._conn.execute(TENANT_CREATE, (name, inbound_source))).fetchone()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def tenant_fetch(self, *, id: int) -> Optional[models.Tenant]:
        row = await (await self._conn.execute(TENANT_FETCH, (id, ))).fetchone()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def tenant_fetch_all(self, *, user_id: int) -> AsyncIterator[models.Tenant]:
        cursor = await self._conn.execute(TENANT_FETCH_ALL, (user_id, ))
        async for row in cursor:
            yield models.Tenant(
                id=row[0],
                external_id=row[1],
                created_at=row[2],
                updated_at=row[3],
                name=row[4],
                inbound_source=row[5],
            )

    async def tenant_fetch_ext(self, *, external_id: str) -> Optional[models.Tenant]:
        row = await (await self._conn.execute(TENANT_FETCH_EXT, (external_id, ))).fetchone()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def test_session_create(self, *, user_id: int, tenant_id: Optional[int], expired_at: Optional[datetime.datetime], last_seen_at: datetime.datetime) -> Optional[models.Session]:
        row = await (await self._conn.execute(TEST_SESSION_CREATE, (user_id, tenant_id, expired_at, last_seen_at))).fetchone()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            user_id=row[4],
            tenant_id=row[5],
            last_seen_at=row[6],
            expired_at=row[7],
        )

    async def test_tenant_create(self, *, name: str, inbound_source: models.TenantsInboundSource) -> Optional[models.Tenant]:
        row = await (await self._conn.execute(TEST_TENANT_CREATE, (name, inbound_source))).fetchone()
        if row is None:
            return None
        return models.Tenant(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            inbound_source=row[5],
        )

    async def test_tenant_user_create(self, *, user_id: int, tenant_id: int) -> Optional[models.TenantsUser]:
        row = await (await self._conn.execute(TEST_TENANT_USER_CREATE, (user_id, tenant_id))).fetchone()
        if row is None:
            return None
        return models.TenantsUser(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            user_id=row[4],
            tenant_id=row[5],
            removed_at=row[6],
            removed_by_user=row[7],
        )

    async def test_user_create(self, *, name: str, email: str, password_hash: Optional[str]) -> Optional[models.User]:
        row = await (await self._conn.execute(TEST_USER_CREATE, (name, email, password_hash))).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def test_user_create_disabled(self, *, name: str, email: str, password_hash: Optional[str]) -> Optional[models.User]:
        row = await (await self._conn.execute(TEST_USER_CREATE_DISABLED, (name, email, password_hash))).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def test_user_create_not_signed_up(self, *, name: str, email: str) -> Optional[models.User]:
        row = await (await self._conn.execute(TEST_USER_CREATE_NOT_SIGNED_UP, (name, email))).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def user_create(self, *, name: str, email: str, password_hash: Optional[str], signup_step: models.UserSignupStep) -> Optional[models.User]:
        row = await (await self._conn.execute(USER_CREATE, (name, email, password_hash, signup_step))).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def user_fetch(self, *, id: int) -> Optional[models.User]:
        row = await (await self._conn.execute(USER_FETCH, (id, ))).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def user_fetch_ext(self, *, external_id: str) -> Optional[models.User]:
        row = await (await self._conn.execute(USER_FETCH_EXT, (external_id, ))).fetchone()
        if row is None:
            return None
        return models.User(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            name=row[4],
            email=row[5],
            password_hash=row[6],
            signup_step=row[7],
            is_enabled=row[8],
            last_visited_at=row[9],
        )

    async def vault_create_secret(self, *, tenant_id: int, ciphertext: str, nonce: str) -> Optional[models.VaultedSecret]:
        row = await (await self._conn.execute(VAULT_CREATE_SECRET, (tenant_id, ciphertext, nonce))).fetchone()
        if row is None:
            return None
        return models.VaultedSecret(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            tenant_id=row[4],
            ciphertext=row[5],
            nonce=row[6],
        )

    async def vault_delete_secret(self, *, id: int) -> None:
        await self._conn.execute(VAULT_DELETE_SECRET, (id, ))

    async def vault_fetch_secret(self, *, id: int) -> Optional[models.VaultedSecret]:
        row = await (await self._conn.execute(VAULT_FETCH_SECRET, (id, ))).fetchone()
        if row is None:
            return None
        return models.VaultedSecret(
            id=row[0],
            external_id=row[1],
            created_at=row[2],
            updated_at=row[3],
            tenant_id=row[4],
            ciphertext=row[5],
            nonce=row[6],
        )
